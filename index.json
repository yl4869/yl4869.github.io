[{"content":"Rust: 泛型，特征与特征对象 最近在学习 Rust 的一些概念思想，记录一下自己对 Rust 中泛型，特征与特征对象的理解。\n泛型 泛型与 CPP 中的模版类似，可以减少代码的重复。泛型会在编译时实现单态化（monomorphization），会将通用代码转换为特定代码，因此不会出现运行时开销。\n可以理解为编译器帮你把写的泛型代码重新转换为写了具体类型的代码。\n泛型可以用在结构体，枚举，函数乃至方法中，其中枚举和方法可以多讲一下。\n泛型在枚举中的实现 泛型在枚举中的实现本身没有要讲的，不过标准库实现的Option\u0026lt;T\u0026gt;和Result\u0026lt;T, E\u0026gt;很想讲一下。\nOption 标准库中的泛型定义\npub enum Option\u0026lt;T\u0026gt; { None, Some(T), } 简约而又简单，rust 中并不存在空指针，通过 None 进行替代，Option常使用在返回值中。当返回值可能为一个结果，也有可能失败或缺值时，可以通过模式匹配进行处理。这里的 T 就是泛型说明\nResult\u0026lt;T, E\u0026gt; 标准库中的泛型定义\npub enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } 除了Option可以在结果失败时传递 None，但有时我们想要知道具体的失败信息，Result 实现了这一点。Result\u0026lt;T, E\u0026gt; 拥有两个泛型 T 和 E，在不同的场景下你可以将他们作为不同的类型。\n泛型在方法中 泛型在方法中需要在impl后面声明\u0026lt;T\u0026gt;，这里是为了告诉 Rust 类型后面的 T 是一个泛型而不是具体类型，注意这里impl后面提供的泛型声明只与后面具体类型要实现的泛型有关。\n与之相应的，你也可以为一个泛型实现他具体类型的方法。\n// 对一个泛型实现具体方法，其中方法中又提供了更多的泛型声明 struct Mix\u0026lt;T, U\u0026gt; { x: T, y: U, } impl\u0026lt;T, U\u0026gt; Mix\u0026lt;T, U\u0026gt; { fn mixup\u0026lt;V, W\u0026gt;(self, other: Mix\u0026lt;V, W\u0026gt;) -\u0026gt; Mix\u0026lt;T, W\u0026gt; { //这里提供了另外两个泛型: V和W, 代表other的类型参数 Mix { x: self.x, y: other.y, } } } fn main() { let x = Mix { x: 1, y: 2.0 }; let y = Mix { x: \u0026#34;hello\u0026#34;, y: \u0026#39;🐺\u0026#39;, }; let z = x.mixup(y); assert_eq!(z.x, 1); assert_eq!(z.y, \u0026#39;🐺\u0026#39;); } 同时我们还可以实现对泛型的具体类型方法\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } impl Point\u0026lt;f32\u0026gt; { fn distance_from_origin(\u0026amp;self) -\u0026gt; f32 { (self.x.powi(2) + self.y.powi(2)).sqrt() } } fn main() { let p = Point { x: 5, y: 10 }; println!(\u0026#34;p.x = {}\u0026#34;, p.x()); } 特征（Trait） 特征的功能：实现一个共同行为\n你可能听说过接口的概念，特征与接口很类似，特征告诉编译器：我有一个共享行为，不同类型都可以实现这个行为\n与C++中的抽象类的继承很类似，但注意特征并非面向对象\n关于特征我想思考的是，孤儿规则与特征约束\n孤儿规则 孤儿规则要求类型和你要为他实现的特征，必须保证他们中有一个在你的定义域内。换言之你无法为String类型实现Display特征，因为他们的定义都在标准库内，你只能进行使用而不能进行修改。\n孤儿规则有效保证了你的代码不会破坏引入的代码，引入的代码也不会破坏你的代码。\n特征约束 impl Trair实际上是一个语法糖，而你想要在复杂场景则可以使用他的完整版：特征约束（trait bound）\n//语法糖版 pub fn notify(item: \u0026amp;impl Summary) { println!(\u0026#34;Breaking news! {}\u0026#34;, item.summarize()); } //特征约束（trait bound） pub fn notify\u0026lt;T: Summary\u0026gt;(item: \u0026amp;T) { println!(\u0026#34;Breaking news! {}\u0026#34;, item.summarize()); } 你也可以指定多个特征约束，特征约束十分灵活，你也可以通过特征约束有条件的实现方法。\n为泛型实现特征 下面是标准库中 Add 特征的实现,这里我们想要为泛型实现\npub trait Add\u0026lt;Rhs = Self\u0026gt; { type Output; fn add(self, rhs: Rhs) -\u0026gt; Self::Output; } //实现两个Point\u0026lt;T\u0026gt;类型的相加 use std::ops::Add; #[derive(Debug, Copy, Clone, PartialEq)] struct Point\u0026lt;T\u0026gt; { x: T, y: T, } // Notice that the implementation uses the associated type `Output`. // 要求 T 类型已经实现了Add trait, 这里使用了特征 impl\u0026lt;T: Add\u0026lt;Output = T\u0026gt;\u0026gt; Add for Point\u0026lt;T\u0026gt; { type Output = Self; fn add(self, other: Self) -\u0026gt; Self::Output { Self { x: self.x + other.x, y: self.y + other.y, } } } assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 }, Point { x: 3, y: 3 }); 这里多了一部分没有介绍到的内容type Output = Self，关联类型（associated types）是指关联到了某个 trait 上的类型。\n关联类型 我们指定Output = Self，又将其作为返回值，同时需要注意，在返回值时我们需要使用Self::Output这种不怎么直观的语法。\n在这里我们直接让返回值为Point\u0026lt;T\u0026gt;而不是Self::Output也没有问题(你可以尝试一下)，那么泛型和关联类型该如何选择。\n简单来说，如果你想对一个类型A对一个 trait 有多种实现，那么使用泛型。\n如果你想对类型A仅实现 trait 一次，那么使用关联类型。\n有关一个类型A多种实现，可以参考From\n特征对象 已经有特征了，为什么还要有特征对象？ 当函数返回值的类型不唯一时（如下面的代码），我们在编译器只能知道返回值的类型满足了某种特征，但无法确定返回值的具体类型，这个时候我们无法进行返回值的使用。\nstruct Sheep {} struct Cow {} trait Animal { fn noise(\u0026amp;self) -\u0026gt; String; } impl Animal for Sheep { fn noise(\u0026amp;self) -\u0026gt; String { \u0026#34;baaaaah!\u0026#34;.to_string() } } impl Animal for Cow { fn noise(\u0026amp;self) -\u0026gt; String { \u0026#34;moooooo!\u0026#34;.to_string() } } // 返回一个类型，该类型实现了 Animal 特征，但是我们并不能在编译期获知具体返回了哪个类型 // 修复这里的错误，你可以使用虚假的随机，也可以使用特征对象 fn random_animal(random_number: f64) -\u0026gt; impl Animal { if random_number \u0026lt; 0.5 { Sheep {} } else { Cow {} } } fn main() { let random_number = 0.234; let animal = random_animal(random_number); println!(\u0026#34;You\u0026#39;ve randomly chosen an animal, and it says {}\u0026#34;, animal.noise()); } 现在，可以考虑特征对象了。\n静态分发与动态分发 特征对象无法使用静态分发，因为我们只能在运行时才知道具体的类型，才能确定会调用什么方法。\n由于类型的大小和方法不确定，所以动态分发提供了指针的方式指向相应的类型和方法，我们通过使用特征对象的引用实现内存的分配。\n有关静态分发与动态分发的区别见下图。 静态分发由于我们在编译器已知类型，因此我们会指向具体的类型实例，但动态分发无法确定类型，因此我们使用内存空间确定的引用类型，包含 ptr 和 vptr 两个指针，分别指向特征对象实例方法的虚表（vtable）我们通过这个虚表可以找到这个实例实现的具体方法。\n这里需要注意的是，当我们选择特征对象时，类型原有的类型被剥夺了，此时 vtable 中只有他作为具体特征的方法，而没有了具体类型实现的方法。\n对象安全 方法的返回类型不能是 Self 方法不能使用泛型参数 因为特征对象已经失去了具体类型，因此我们如果我们返回了具体的Self类型，无法确定这个类型是什么。同样，对于泛型类型参数，我们会在编译器放入具体参数，当特征对象会导致具体类型被丢弃，我们也无法得知放入的泛型参数类型是什么。\n特征对象的使用 一句话：特征对象有两种使用方式\u0026amp;dyn A和Box\u0026lt;dyn A\u0026gt;，区别上面也讲过了。\n","permalink":"http://yl4869.github.io/posts/rust/generics_trait/","summary":"Rust: 泛型，特征与特征对象 最近在学习 Rust 的一些概念思想，记录一下自己对 Rust 中泛型，特征与特征对象的理解。\n泛型 泛型与 CPP 中的模版类似，可以减少代码的重复。泛型会在编译时实现单态化（monomorphization），会将通用代码转换为特定代码，因此不会出现运行时开销。\n可以理解为编译器帮你把写的泛型代码重新转换为写了具体类型的代码。\n泛型可以用在结构体，枚举，函数乃至方法中，其中枚举和方法可以多讲一下。\n泛型在枚举中的实现 泛型在枚举中的实现本身没有要讲的，不过标准库实现的Option\u0026lt;T\u0026gt;和Result\u0026lt;T, E\u0026gt;很想讲一下。\nOption 标准库中的泛型定义\npub enum Option\u0026lt;T\u0026gt; { None, Some(T), } 简约而又简单，rust 中并不存在空指针，通过 None 进行替代，Option常使用在返回值中。当返回值可能为一个结果，也有可能失败或缺值时，可以通过模式匹配进行处理。这里的 T 就是泛型说明\nResult\u0026lt;T, E\u0026gt; 标准库中的泛型定义\npub enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } 除了Option可以在结果失败时传递 None，但有时我们想要知道具体的失败信息，Result 实现了这一点。Result\u0026lt;T, E\u0026gt; 拥有两个泛型 T 和 E，在不同的场景下你可以将他们作为不同的类型。\n泛型在方法中 泛型在方法中需要在impl后面声明\u0026lt;T\u0026gt;，这里是为了告诉 Rust 类型后面的 T 是一个泛型而不是具体类型，注意这里impl后面提供的泛型声明只与后面具体类型要实现的泛型有关。\n与之相应的，你也可以为一个泛型实现他具体类型的方法。\n// 对一个泛型实现具体方法，其中方法中又提供了更多的泛型声明 struct Mix\u0026lt;T, U\u0026gt; { x: T, y: U, } impl\u0026lt;T, U\u0026gt; Mix\u0026lt;T, U\u0026gt; { fn mixup\u0026lt;V, W\u0026gt;(self, other: Mix\u0026lt;V, W\u0026gt;) -\u0026gt; Mix\u0026lt;T, W\u0026gt; { //这里提供了另外两个泛型: V和W, 代表other的类型参数 Mix { x: self.","title":"Rust: 泛型，特征与特征对象"},{"content":"Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop 在做HDLbits时，有一道很有趣的双边沿触发器问题 ，这里记录一下相关内容和解答方式。\n问题描述 实现一个双边沿触发器，即在时钟的上升沿和下降沿都被触发。\nmodule top_module ( input clk, input d, output q ); 问题 无法直接通过always @(posedge clk or negedge clk)直接创建双边沿触发器，FPGA 中只能存在单边沿触发器。\n但是你可以创建两个触发器，分别是上升沿和下降沿。\n解决方案（1） 虽然我们无法直接创建双边沿触发器，但是可以通过使用两个触发器和一个多路选择器实现相同的功能。\nmodule top_module ( input clk, input d, output q ); reg q1; reg q2; always @(posedge clk) begin q1 \u0026lt;= d; end always @(negedge clk) begin q2 \u0026lt;= d; end assign q = clk ? q1 : q2; endmodule 注意，你可能想要两个触发器内都填写q \u0026lt;= d，这在思维上是合理的，但是在实现中会引入多驱问题。\n但这又引入了另一个问题：毛刺（glitch）的出现，因为触发器的输出会存在一个延迟。\n解决方案（2） 解决毛刺的一种方案，也是HDLbits给出的答案：通过异或门消除毛刺\nmodule top_module( input clk, input d, output q); reg p, n; always @(posedge clk) p \u0026lt;= d ^ n; always @(negedge clk) n \u0026lt;= d ^ p; assign q = p ^ n; endmodule 通过上面的方案，对于上升沿的选择p ^ n = d ^ n ^ n = d，对于下降沿p ^ n = n ^ d ^ n = d。由于 p 和 n 都通过触发器产生，因此可以消除毛刺。\n总结 由于硬件的限制，手动实现双边沿触发器需要一些\u0026rsquo;小技巧\u0026rsquo;，同时也要注意毛刺的消除。\n附页 [Synth 8-91]相关问题的解释，Xilinx社区\n","permalink":"http://yl4869.github.io/posts/verilog/dual-edge_triggered_flip-flop/","summary":"Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop 在做HDLbits时，有一道很有趣的双边沿触发器问题 ，这里记录一下相关内容和解答方式。\n问题描述 实现一个双边沿触发器，即在时钟的上升沿和下降沿都被触发。\nmodule top_module ( input clk, input d, output q ); 问题 无法直接通过always @(posedge clk or negedge clk)直接创建双边沿触发器，FPGA 中只能存在单边沿触发器。\n但是你可以创建两个触发器，分别是上升沿和下降沿。\n解决方案（1） 虽然我们无法直接创建双边沿触发器，但是可以通过使用两个触发器和一个多路选择器实现相同的功能。\nmodule top_module ( input clk, input d, output q ); reg q1; reg q2; always @(posedge clk) begin q1 \u0026lt;= d; end always @(negedge clk) begin q2 \u0026lt;= d; end assign q = clk ? q1 : q2; endmodule 注意，你可能想要两个触发器内都填写q \u0026lt;= d，这在思维上是合理的，但是在实现中会引入多驱问题。","title":"Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop"},{"content":"右值引用：移动语义 左值与右值 左值有标识 标识：你有某个值，并有某个值的内存地址，可以安全的使用它\n左值(lvalue)可以出现在赋值的左侧（当我们使用他的名称时），也可以出现在赋值的右侧（当我们使用他的值时）。因此当我们称某个值为左值时，他未必出现在等号左侧，而是认为他有标识。\n这里的左值严格意义上称为泛左值，包括左值和将亡值两种。\n右值可移动，左值不能 有些值并非泛左值，换句话说你无法获得其内存地址并使用。这类值的优点是可以移动他而不是复制它。（通常情况下移动要比赋值开销小很多）。移动一个值意味着他不会在原来的位置，当你称一个值可以移动时，我们认为是右值。\n左值是不可移动的，因为这破坏了左值的概念：通过内存地址使用\n右值引用的对象，是临时的，即将被销毁。\n纯右值 纯右值没有标识，因此我们无法使用他的内存地址，但他是可以移动的（因为是右值）。\n值类别汇总 泛左值（glvalue）：有标识 左值：有标识但不能移动 将亡值：有标识，但也可以移动，是之前的某个左值变成了右值引用。 纯右值：没有标识，可以移动。 右值：可移动 左值持久，右值短暂\n左值引用与右值引用 重新观察T\u0026amp; 重新观察T\u0026amp;和const T\u0026amp;，他们现在实际上是对左值的引用。左值引用可以绑定到左值，但不可以绑定到右值。\n左值引用时，我们将一个对象的内存空间绑定到另一个变量上，因此我们使用的是一个对象在内存中的位置，这是一个左值。\n右值引用 通过T\u0026amp;\u0026amp;可以标识一个类型T的右值引用，右值引用引用了一个可移动值，其内容在使用后无需保留。右值引用绑定到右值而非左值（右值引用假定内容无需保留而进行移动的值）。\n右值引用意味着：1.右值是临时的，即将被销毁。 2.右值引用的对象不会在其他地方使用。\n这两个特性意味着：接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏。\n右值引用是左值还是右值 对于左值引用，当我们想要使用他的值时，他是右值，当我们想要使用他的地址（内存空间）时，他是左值。对于右值引用也一样，当我们进行右值引用时，右值的变量已经被右值引用接管了，这个时候的变量可以通过右值引用保存下来，因此可以成为左值。而我们也可以直接使用右值引用的值，这个时候右值引用会作为右值。\n移动语义 右值引用支持“移动语义”，利用移动语义，你可以让一个对象转移到另一个对象而非使用拷贝构造，他也可以使用临时对象转移资源。\n右值中的数据可以被安全移走使得右值可以用来表达移动语义。\n考虑vector对象的实例，当vector容量满时，我们会开辟一块新的空间并将内容拷贝构造到新空间，销毁之前的空间。但拥有了移动语义后，我们可以实现移动而非拷贝，这可以避免成本高昂的内存分配和复制操作。\n","permalink":"http://yl4869.github.io/posts/learn_c_cpp/rvalue1/","summary":"右值引用：移动语义 左值与右值 左值有标识 标识：你有某个值，并有某个值的内存地址，可以安全的使用它\n左值(lvalue)可以出现在赋值的左侧（当我们使用他的名称时），也可以出现在赋值的右侧（当我们使用他的值时）。因此当我们称某个值为左值时，他未必出现在等号左侧，而是认为他有标识。\n这里的左值严格意义上称为泛左值，包括左值和将亡值两种。\n右值可移动，左值不能 有些值并非泛左值，换句话说你无法获得其内存地址并使用。这类值的优点是可以移动他而不是复制它。（通常情况下移动要比赋值开销小很多）。移动一个值意味着他不会在原来的位置，当你称一个值可以移动时，我们认为是右值。\n左值是不可移动的，因为这破坏了左值的概念：通过内存地址使用\n右值引用的对象，是临时的，即将被销毁。\n纯右值 纯右值没有标识，因此我们无法使用他的内存地址，但他是可以移动的（因为是右值）。\n值类别汇总 泛左值（glvalue）：有标识 左值：有标识但不能移动 将亡值：有标识，但也可以移动，是之前的某个左值变成了右值引用。 纯右值：没有标识，可以移动。 右值：可移动 左值持久，右值短暂\n左值引用与右值引用 重新观察T\u0026amp; 重新观察T\u0026amp;和const T\u0026amp;，他们现在实际上是对左值的引用。左值引用可以绑定到左值，但不可以绑定到右值。\n左值引用时，我们将一个对象的内存空间绑定到另一个变量上，因此我们使用的是一个对象在内存中的位置，这是一个左值。\n右值引用 通过T\u0026amp;\u0026amp;可以标识一个类型T的右值引用，右值引用引用了一个可移动值，其内容在使用后无需保留。右值引用绑定到右值而非左值（右值引用假定内容无需保留而进行移动的值）。\n右值引用意味着：1.右值是临时的，即将被销毁。 2.右值引用的对象不会在其他地方使用。\n这两个特性意味着：接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏。\n右值引用是左值还是右值 对于左值引用，当我们想要使用他的值时，他是右值，当我们想要使用他的地址（内存空间）时，他是左值。对于右值引用也一样，当我们进行右值引用时，右值的变量已经被右值引用接管了，这个时候的变量可以通过右值引用保存下来，因此可以成为左值。而我们也可以直接使用右值引用的值，这个时候右值引用会作为右值。\n移动语义 右值引用支持“移动语义”，利用移动语义，你可以让一个对象转移到另一个对象而非使用拷贝构造，他也可以使用临时对象转移资源。\n右值中的数据可以被安全移走使得右值可以用来表达移动语义。\n考虑vector对象的实例，当vector容量满时，我们会开辟一块新的空间并将内容拷贝构造到新空间，销毁之前的空间。但拥有了移动语义后，我们可以实现移动而非拷贝，这可以避免成本高昂的内存分配和复制操作。","title":"右值引用: 移动语义"},{"content":"数据库系统 数据库 什么是数据库？ 将信息以某种形式存储在一起。\n数据库的重要位置 系统软件之一，为多种应用软件提供基础。\n注意数据库（Database）与数据库管理系统（Database management system，DBMS）的区别。\n传统数据整理 传统数据整理的方式：一种方式为 CSV 的表格式存储。\n缺点：安全性，效率性，使用时的复杂度等。\n如无法保证在数字栏插入的一定是数字。检索需要遍历，出现问题容易直接崩溃等。\n早期的DBMS DBMS：软件层面上对数据模型进行定义，提供了增删改查等功能。\n早期的数据模型：逻辑与物理紧密结合，必须对特定的数据库场景安排对应的处理应用。\n根本原因为物理存储上直接采用应用对数据格式，位置等进行规定，因此切换场景等都需要重新进行设计。\n关系模型 基于关系定义了一种数据模型的抽象。\n利用一种简单的数据结构（关系）进行数据库存储 用户操作基于高级语言，DBMS 负责具体执行策略 物理存储由 DBMS 负责实现。 关系模型是将无序的各种数据通过关系串联起来，而对这些数据的操作和物理存储的实现都交给了 DBMS，因此使用者可以相对透明的完成对数据的处理。\n关系模型也定义了三个概念：\n数据结构 数据操作 数据约束 关系模型利用了数学上的关系定义\n主键与外键 主键：每个关系中唯一的键，作为该关系的关键字。（如省略，一般会自动生成）\n外键：提供关系与关系间的纽带。\nDML Data Manipulation Languages，数据操作语言，用来操作数据库表中的记录。\n中文可以理解成增删改查四种操作。\n常见的两种分类：\nProcedural: 指定了做什么，和如何做 Non-Procedural(Declaratice): 仅仅指定了做什么 关系代数 关系代数是对关系模型中各种运算操作的集合（前面说了关系模型其实是一种数学的关系定义）。\n注意和数学上的关系运算并不完全相同。\n“选择”、“投影”、笛卡尔积（也叫做“叉积”或“交叉连接”）、并集、差集、“重命名”、“自然连接”。\n利用关系代数我们可以解释两种 DML 的不同之处：\nProcedural：σb id=102(R ▷◁ S)，既解释了做什么，也解释了如何做 Non-Procedural：(retrieve the joined tuples from R and S where bid equals 102，只说明了做什么，没有说明如何做，指定关系代数顺序） 第二种交给了 DBMS 来完成。\nSQL 对关系模型的一种语言实现，现阶段使用最广泛的一种。\nNon-Procedural\nReference cmu15-445 一门广受好评的数据库系统课程\n维基百科 维基百科，自由的百科全书\n","permalink":"http://yl4869.github.io/posts/database_systems/dbs1/","summary":"数据库系统 数据库 什么是数据库？ 将信息以某种形式存储在一起。\n数据库的重要位置 系统软件之一，为多种应用软件提供基础。\n注意数据库（Database）与数据库管理系统（Database management system，DBMS）的区别。\n传统数据整理 传统数据整理的方式：一种方式为 CSV 的表格式存储。\n缺点：安全性，效率性，使用时的复杂度等。\n如无法保证在数字栏插入的一定是数字。检索需要遍历，出现问题容易直接崩溃等。\n早期的DBMS DBMS：软件层面上对数据模型进行定义，提供了增删改查等功能。\n早期的数据模型：逻辑与物理紧密结合，必须对特定的数据库场景安排对应的处理应用。\n根本原因为物理存储上直接采用应用对数据格式，位置等进行规定，因此切换场景等都需要重新进行设计。\n关系模型 基于关系定义了一种数据模型的抽象。\n利用一种简单的数据结构（关系）进行数据库存储 用户操作基于高级语言，DBMS 负责具体执行策略 物理存储由 DBMS 负责实现。 关系模型是将无序的各种数据通过关系串联起来，而对这些数据的操作和物理存储的实现都交给了 DBMS，因此使用者可以相对透明的完成对数据的处理。\n关系模型也定义了三个概念：\n数据结构 数据操作 数据约束 关系模型利用了数学上的关系定义\n主键与外键 主键：每个关系中唯一的键，作为该关系的关键字。（如省略，一般会自动生成）\n外键：提供关系与关系间的纽带。\nDML Data Manipulation Languages，数据操作语言，用来操作数据库表中的记录。\n中文可以理解成增删改查四种操作。\n常见的两种分类：\nProcedural: 指定了做什么，和如何做 Non-Procedural(Declaratice): 仅仅指定了做什么 关系代数 关系代数是对关系模型中各种运算操作的集合（前面说了关系模型其实是一种数学的关系定义）。\n注意和数学上的关系运算并不完全相同。\n“选择”、“投影”、笛卡尔积（也叫做“叉积”或“交叉连接”）、并集、差集、“重命名”、“自然连接”。\n利用关系代数我们可以解释两种 DML 的不同之处：\nProcedural：σb id=102(R ▷◁ S)，既解释了做什么，也解释了如何做 Non-Procedural：(retrieve the joined tuples from R and S where bid equals 102，只说明了做什么，没有说明如何做，指定关系代数顺序） 第二种交给了 DBMS 来完成。","title":"数据库系统（一）"},{"content":"前言 我利用github pages作为平台搭建我的博客，我开始选择将博客内容和部署分成两个仓库存放，但这显然造成了复杂性的提升。在阅读 mdbook 的官方文档时，我发现他部署 book 的一个方式是利用一个新的分支进行部署，这样可以将内容和页面放在不同的分支上共同保存，同时有好的规整感。\n原理 在 github 仓库的 Settings/Pages 下可以选择利用哪一个分支进行部署。\n利用 github worktree 可以将当前分支绑定到一个新建的 worktree 目录上，并通过新的目录进行分支操作。\n使用 新建分支 deploy 和 /tmp/blog 目录，利用github worktree 将目录 deploy 分支绑定到目录下。 将生成的页面文件（我这里在public文件夹中），拷贝到 /tmp/blog 目录下 在 /tmp/blog 下利用 git 操作，添加并提交到远程 deploy 分支中。 设置 github pages，用 deploy 分支作为 github pages 部署分支。 现在你可以将内容提交到 main 分支，而将部署提交到 deploy分支。\n为什么使用临时目录 使用临时目录的样例来自 mdbook 的文档。因此我只是当一个黑盒来使用。我的想法是为了不破坏其他数据，不过有了解的朋友也欢迎来给我答疑解惑。\n我的 Makefile 文件 .PHONY: deploy .PHONY: clean .PHONY: build .PHONY: commit clean: rm -rf public deploy: public @echo \u0026#34;====\u0026gt; deploying to github\u0026#34; -mkdir /tmp/blog git worktree prune -git worktree add /tmp/blog deploy rm -rf /tmp/blog/* cp -rp public/* /tmp/blog/ cd /tmp/blog \u0026amp;\u0026amp; \\ git add -A \u0026amp;\u0026amp; \\ git commit -m \u0026#34;deployed on $(shell date) by ${USER}\u0026#34; \u0026amp;\u0026amp; \\ git push origin deploy cd - build: hugo commit: git add Makefile config.yml assets static content layouts archetypes git commit -m \u0026#34;commit on $(shell date) by ${USER}\u0026#34; \u0026amp;\u0026amp; \\ git push origin main ","permalink":"http://yl4869.github.io/posts/make_better_github_pages/","summary":"前言 我利用github pages作为平台搭建我的博客，我开始选择将博客内容和部署分成两个仓库存放，但这显然造成了复杂性的提升。在阅读 mdbook 的官方文档时，我发现他部署 book 的一个方式是利用一个新的分支进行部署，这样可以将内容和页面放在不同的分支上共同保存，同时有好的规整感。\n原理 在 github 仓库的 Settings/Pages 下可以选择利用哪一个分支进行部署。\n利用 github worktree 可以将当前分支绑定到一个新建的 worktree 目录上，并通过新的目录进行分支操作。\n使用 新建分支 deploy 和 /tmp/blog 目录，利用github worktree 将目录 deploy 分支绑定到目录下。 将生成的页面文件（我这里在public文件夹中），拷贝到 /tmp/blog 目录下 在 /tmp/blog 下利用 git 操作，添加并提交到远程 deploy 分支中。 设置 github pages，用 deploy 分支作为 github pages 部署分支。 现在你可以将内容提交到 main 分支，而将部署提交到 deploy分支。\n为什么使用临时目录 使用临时目录的样例来自 mdbook 的文档。因此我只是当一个黑盒来使用。我的想法是为了不破坏其他数据，不过有了解的朋友也欢迎来给我答疑解惑。\n我的 Makefile 文件 .PHONY: deploy .PHONY: clean .PHONY: build .PHONY: commit clean: rm -rf public deploy: public @echo \u0026#34;====\u0026gt; deploying to github\u0026#34; -mkdir /tmp/blog git worktree prune -git worktree add /tmp/blog deploy rm -rf /tmp/blog/* cp -rp public/* /tmp/blog/ cd /tmp/blog \u0026amp;\u0026amp; \\ git add -A \u0026amp;\u0026amp; \\ git commit -m \u0026#34;deployed on $(shell date) by ${USER}\u0026#34; \u0026amp;\u0026amp; \\ git push origin deploy cd - build: hugo commit: git add Makefile config.","title":"利用分支完成 github pages 博客内容存放和页面部署"},{"content":"目标 对这个 网页中的数据集进行数据处理,选择一列 找出最大值和最小值, 选择其中两列求出差值并求和.\n步骤 对于html, 可以使用wget或curl读入. 处理html内容可以采用pup工具来实现.\n下载网页到本地\nwget https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm -O pra.html 对网站元素进行查看 最好的方法是使用浏览器的审查元素方式进行查看, 能够较快的找到自己所需的内容.\n可以看到我们所需的数据表格在table中,id为table1.更近一步观察可以看到位于tbody中.可以通过pup过滤并 输出内容.\n数据处理 通过pup获取html中第一个表格的数据 cat pra.html | pup \u0026#39;table#table1 tbody td next{}\u0026#39; 此时内容如图\n去除头部和尾部部分行 对于表格文件,我只关心表格中间的数据，而忽略表头和表尾，这里采用head和tail进行过滤.\n删除尾部30行,删除头部208（209-1）行.\nhead -n -30 tail -n +209 将列变为行，以空格分割 相对于一列，我更喜欢处理以整行数据,这样就可以利用awk的$获取分割.\n通过tr命令进行替换\ntr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39; awk awk是一种善于处理文本的编程语言,他太强大了,以至于我们可以用awk完成其余的所有操作.\nawk \u0026#39;{sum = 0;max = 0; min = 65536;for(i = 2;i \u0026lt; 4302; i+=20) {if(max \u0026lt; $i) max = $i; if(min \u0026gt; $i) \\ min = $i; if($i \u0026gt; $(i+1)) sum += $i - $(i+1); if($i \u0026lt;= $(i+1)) sum += $(i+1) - $i;}print max; print \\ min; print sum } 正如我们所说，awk是一种编程语言，代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的 分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。\n这里一个有趣的是,由于awk本来是以空格分割,而对于1.2 Mb,我以为他也会被分割,导致我无法获取正确的结果. 但情况是分割正确.通过分析发现这中间的空格并不是我们通常的ASCII 32.还有一个特殊的空格是ASCII 160. 是\u0026amp;nbsp产生的空格\n通过awk,我可以完成之后的全部操作.\n至此我们获得了一个特别长的命令行操作,他们之间由pipe处理\ncat pra.html | pup \u0026#39;table#table1 tbody td text{}\u0026#39; | head -n -30 | tail -n +209 | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39; | awk \\ \u0026#39;{sum = 0;max = 0; min = 65536;for(i = 2;i \u0026lt; 4320; i+=20) {if(max \u0026lt; $i) max = $i; if(min \u0026gt; $i) min \\ = $i; if($i \u0026gt; $(i+1)) sum += $i - $(i+1); if($i \u0026lt;= $(i+1)) sum += $(i+1) - $i;}print max; print min\\ ; print sum }\u0026#39; 最后结果如下 总结 通过命令行进行数据处理需要多种工具相互结合.其中比较常用的有tr,sed,awk,sort,head,tail等.\n正则表达式很有用,虽然这道练习只用到了替换.\n你不能期待一个操作解决全部问题,通过管道,你可以将问题拆分为多个小问题并利用多个工具完成操作.\n","permalink":"http://yl4869.github.io/posts/learn_linux/data_wrangling/","summary":"目标 对这个 网页中的数据集进行数据处理,选择一列 找出最大值和最小值, 选择其中两列求出差值并求和.\n步骤 对于html, 可以使用wget或curl读入. 处理html内容可以采用pup工具来实现.\n下载网页到本地\nwget https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm -O pra.html 对网站元素进行查看 最好的方法是使用浏览器的审查元素方式进行查看, 能够较快的找到自己所需的内容.\n可以看到我们所需的数据表格在table中,id为table1.更近一步观察可以看到位于tbody中.可以通过pup过滤并 输出内容.\n数据处理 通过pup获取html中第一个表格的数据 cat pra.html | pup \u0026#39;table#table1 tbody td next{}\u0026#39; 此时内容如图\n去除头部和尾部部分行 对于表格文件,我只关心表格中间的数据，而忽略表头和表尾，这里采用head和tail进行过滤.\n删除尾部30行,删除头部208（209-1）行.\nhead -n -30 tail -n +209 将列变为行，以空格分割 相对于一列，我更喜欢处理以整行数据,这样就可以利用awk的$获取分割.\n通过tr命令进行替换\ntr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39; awk awk是一种善于处理文本的编程语言,他太强大了,以至于我们可以用awk完成其余的所有操作.\nawk \u0026#39;{sum = 0;max = 0; min = 65536;for(i = 2;i \u0026lt; 4302; i+=20) {if(max \u0026lt; $i) max = $i; if(min \u0026gt; $i) \\ min = $i; if($i \u0026gt; $(i+1)) sum += $i - $(i+1); if($i \u0026lt;= $(i+1)) sum += $(i+1) - $i;}print max; print \\ min; print sum } 正如我们所说，awk是一种编程语言，代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的 分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。","title":"数据处理练习"},{"content":"前言 最近一直在做一生一芯，跟着做了些PA的项目，感觉自己之前很多所学都有了很多欠缺，也越发发现学校在培养计 划上的自己认为的一些不合理地方，在此记录下:自己如果回到大一，可能会如何开始学习（顺带考虑一下培养计划）。\n大一上 应该在大一上学到一门导论课，去知道自己大学四年应该学什么，可以学什么，同时可以将这些知识进行一个简单的串联， 未必要将每一个知识点学的很深，但希望可以覆盖到每一个知识点。\n程序设计基础肯定要有，但课设（挺想把C语言课设搬到大一上的，这里一并说了）希望可以有一个培养为上，内容次之的 过程。\n现在的课设很多开始已经是报告要卷，内容要卷的状态了。什么数据库，前端，GUI，一些“卷王”做出了很多远超于 课设本身内容的事情。\n希望课设是将课上所学实践起来。而不是在各种内容之外的地方去竞争。也希望未来的学弟学妹都能够真正自己思考,动手 写出课设，而不是在网上copy代码。\n可以让学生多学一些工具，比如利用git进行团队协作（老实说这个我现在都还没做好），通过make工具链编译。未必要成为 课设加分项，但也可以让学生开始接触一些试试（我现在就在被makefile折磨）。\n这里点赞一下我们的实验课老师，他实验课的开始就让我们体会了一些git的用法，据说现在学弟学妹还可以在CG平台实验了。\n大一下 学会工具使用！学会工具使用！学会工具使用！\n一定需要一门课来教一些工具的使用了，命令行，shell，版本控制，文本编辑\u0026hellip;。狂吹The missing semester of your CS education 。\n如果说大一上已经开始接触git了，你可能感受到（或没有）他的便利，如果没有，尝试继续在日常使用。\n如果你没有开始，用qq，U盘传文件的方式已经让你感到麻烦，开始git吧，找寻一种更高效（开始可能不）的方法。\n学会使用这些工具未必能让你立刻觉得你付出的时间会有回报，但他们一定会穿插在你学习计算机的每一个时刻。\n对于C++，老师上课第一件要说的就是：学的是面向对象程序设计，只是用C++来教学，因此将更多实时间放在面向对象 上应该是个好主意。\n装一台虚拟机，装上linux（颇有私货），但从无到有掌握linux确实能提高很多你的能力（包括查阅文档）。\n建议 老师的PPT很老，对于教学来讲足够了，但对于计算机前沿来讲显得过于陈旧。可以多上网冲浪看一看，现代计算机发展到了哪一个阶段。\n多实践，多敲键盘，学会计算机的最好办法。\n查阅手册，查看代码，搜索网页。解决问题的最好办法\n结语 祝你早日成为计算机科学家\n","permalink":"http://yl4869.github.io/posts/learn/","summary":"前言 最近一直在做一生一芯，跟着做了些PA的项目，感觉自己之前很多所学都有了很多欠缺，也越发发现学校在培养计 划上的自己认为的一些不合理地方，在此记录下:自己如果回到大一，可能会如何开始学习（顺带考虑一下培养计划）。\n大一上 应该在大一上学到一门导论课，去知道自己大学四年应该学什么，可以学什么，同时可以将这些知识进行一个简单的串联， 未必要将每一个知识点学的很深，但希望可以覆盖到每一个知识点。\n程序设计基础肯定要有，但课设（挺想把C语言课设搬到大一上的，这里一并说了）希望可以有一个培养为上，内容次之的 过程。\n现在的课设很多开始已经是报告要卷，内容要卷的状态了。什么数据库，前端，GUI，一些“卷王”做出了很多远超于 课设本身内容的事情。\n希望课设是将课上所学实践起来。而不是在各种内容之外的地方去竞争。也希望未来的学弟学妹都能够真正自己思考,动手 写出课设，而不是在网上copy代码。\n可以让学生多学一些工具，比如利用git进行团队协作（老实说这个我现在都还没做好），通过make工具链编译。未必要成为 课设加分项，但也可以让学生开始接触一些试试（我现在就在被makefile折磨）。\n这里点赞一下我们的实验课老师，他实验课的开始就让我们体会了一些git的用法，据说现在学弟学妹还可以在CG平台实验了。\n大一下 学会工具使用！学会工具使用！学会工具使用！\n一定需要一门课来教一些工具的使用了，命令行，shell，版本控制，文本编辑\u0026hellip;。狂吹The missing semester of your CS education 。\n如果说大一上已经开始接触git了，你可能感受到（或没有）他的便利，如果没有，尝试继续在日常使用。\n如果你没有开始，用qq，U盘传文件的方式已经让你感到麻烦，开始git吧，找寻一种更高效（开始可能不）的方法。\n学会使用这些工具未必能让你立刻觉得你付出的时间会有回报，但他们一定会穿插在你学习计算机的每一个时刻。\n对于C++，老师上课第一件要说的就是：学的是面向对象程序设计，只是用C++来教学，因此将更多实时间放在面向对象 上应该是个好主意。\n装一台虚拟机，装上linux（颇有私货），但从无到有掌握linux确实能提高很多你的能力（包括查阅文档）。\n建议 老师的PPT很老，对于教学来讲足够了，但对于计算机前沿来讲显得过于陈旧。可以多上网冲浪看一看，现代计算机发展到了哪一个阶段。\n多实践，多敲键盘，学会计算机的最好办法。\n查阅手册，查看代码，搜索网页。解决问题的最好办法\n结语 祝你早日成为计算机科学家","title":"对大一应该学些什么的一点思考"},{"content":"介绍 Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。\n算法主要通过维护结点集合S。通过从结点集V-S中选择最短路径最小的结点u,将其加入进S中，并对所有从u发出可到达V-S集合中结点的边进行松弛操作。\n对邻接表进行操作\n松弛操作：对于一条从 顶点u指向 顶点v的边 u\u0026ndash;\u0026gt;v来说，如果满足 d[u]+w(u,v)\u0026lt;d[v],就更新 d[v],使得 d[v]=d[u]+w(u,v)；这就是对 边uv的一次放松操作；\n其中，w(u,v)表示边的权重，d(u)表示顶点u到达源s的最短距离(目前已知)\n因此我们可以将算法理解为三个操作：1.找到V-S集合中距离S集合最小结点 2.将结点加入S集合中 3.对V-S中剩余结点进行松弛操作。\n算法描述 解释 算法的主要逻辑为while循环。Q始终为Q=V-S。每一次通过EXTRACT-MIN(Q)取出Q中距离最小值u。并将u放入S集合中。之后在for循环中对Q中剩余结点进行松弛操作。\n对距离进行更新。\n分析 算法通过每次从Q中找出距离最小的一个结点插入到S中，并将Q中剩余的结点距离进行松弛，直到Q中没有结点结束。因为Q中初始结点一共有V个，因此一定会有一次O(V)操作(全部插入)。\n注意到我们每次只需要松弛刚插入结点连接到的表，由于采用邻接表操作，我们对每一个边只会松弛一次，因此一共会执行|E|次。\n找到最小结点的操作可以有多种方式实现，下面介绍三种。\n利用一次遍历实现(常通过维护数组) 我们每一次都通过遍历Q中全部结点找到最小值，这时候需要对一次插入结点都需要执行一个O(V)操作。算法的时间复杂度为\n$$ O(V^2 + E) = O(V^2) $$\n利用二叉堆实现 显然，如果我们每一次都要找到最小值，可以通过使用二叉堆实现优先队列来优化寻找最小值的算法。这样我们可以将查找最小值的操作优化到O(lgV)\n而对于二叉堆，每一次修改距离并加入到二叉堆都需要一次更新，因此复杂了松弛操作，时间复杂度为\n$$ O((V+E)lgV) $$\n即每一次删除Q中一个结点和将结点距离松弛化都需要lgV时间\n因此，是否优于第一种需要考虑E的范围，即图是稀疏图还是稠密图\n利用斐波那契堆 斐波那契堆的对于找到最小值并进行删除需要的时间与二叉堆一样，都是O(lgV)，但对松弛操作，斐波那契堆的摊还代价是O(1),因此可以实现更好的优化，他的时间复杂度为\n$$ O(VlgV + E) $$\n","permalink":"http://yl4869.github.io/posts/ad/dijkstra/","summary":"介绍 Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。\n算法主要通过维护结点集合S。通过从结点集V-S中选择最短路径最小的结点u,将其加入进S中，并对所有从u发出可到达V-S集合中结点的边进行松弛操作。\n对邻接表进行操作\n松弛操作：对于一条从 顶点u指向 顶点v的边 u\u0026ndash;\u0026gt;v来说，如果满足 d[u]+w(u,v)\u0026lt;d[v],就更新 d[v],使得 d[v]=d[u]+w(u,v)；这就是对 边uv的一次放松操作；\n其中，w(u,v)表示边的权重，d(u)表示顶点u到达源s的最短距离(目前已知)\n因此我们可以将算法理解为三个操作：1.找到V-S集合中距离S集合最小结点 2.将结点加入S集合中 3.对V-S中剩余结点进行松弛操作。\n算法描述 解释 算法的主要逻辑为while循环。Q始终为Q=V-S。每一次通过EXTRACT-MIN(Q)取出Q中距离最小值u。并将u放入S集合中。之后在for循环中对Q中剩余结点进行松弛操作。\n对距离进行更新。\n分析 算法通过每次从Q中找出距离最小的一个结点插入到S中，并将Q中剩余的结点距离进行松弛，直到Q中没有结点结束。因为Q中初始结点一共有V个，因此一定会有一次O(V)操作(全部插入)。\n注意到我们每次只需要松弛刚插入结点连接到的表，由于采用邻接表操作，我们对每一个边只会松弛一次，因此一共会执行|E|次。\n找到最小结点的操作可以有多种方式实现，下面介绍三种。\n利用一次遍历实现(常通过维护数组) 我们每一次都通过遍历Q中全部结点找到最小值，这时候需要对一次插入结点都需要执行一个O(V)操作。算法的时间复杂度为\n$$ O(V^2 + E) = O(V^2) $$\n利用二叉堆实现 显然，如果我们每一次都要找到最小值，可以通过使用二叉堆实现优先队列来优化寻找最小值的算法。这样我们可以将查找最小值的操作优化到O(lgV)\n而对于二叉堆，每一次修改距离并加入到二叉堆都需要一次更新，因此复杂了松弛操作，时间复杂度为\n$$ O((V+E)lgV) $$\n即每一次删除Q中一个结点和将结点距离松弛化都需要lgV时间\n因此，是否优于第一种需要考虑E的范围，即图是稀疏图还是稠密图\n利用斐波那契堆 斐波那契堆的对于找到最小值并进行删除需要的时间与二叉堆一样，都是O(lgV)，但对松弛操作，斐波那契堆的摊还代价是O(1),因此可以实现更好的优化，他的时间复杂度为\n$$ O(VlgV + E) $$","title":"Dijkstra算法-三种实现与复杂度分析"},{"content":"Rust介绍 官网对rust的介绍为一门赋予每个人构建可靠且高效软件能力的语言。\nRust是一门系统编程语言。简单来说，系统编程语言是一种资源受限的编程，你需要对每个字节和每个CPU时钟周期精打细算，做到高效的完成任务。\n常见的系统编程应用场景:\n操作系统 各种设备驱动 文件系统 数据库 嵌入式设备 内存管理程序 高级编程语言 虚拟化及软件程序 游戏 等等\u0026hellip; 为什么选择Rust 系统编程语言已经有C/CPP了，为什么我还要选择Rust? C语言诞生于1972年，C++诞生于1979年，这至今41+年的时光中一直没有编程语言去挑战他们的地位。\n由于时代原因，C和C++是两门过于相信程序员的编程语言，不会去检查程序员出错的代码。\nRust的第一个正式版本发布于2015年，融合了现代编程语言的优秀设计，解决了传统系统编程语言的痛点问题。产生了高性能，可靠性，生产力三个优秀特点。\n最值得一提的是可靠性，Rust的设计使得你可以在编译器解决各种错误，而不是运行时。同时他的这种设计也让多核时代的多线程编写变得更加简单。\n又有谁没被segmentation fault折磨过呢？\n享受编程 一旦你学会了rust，你就会享受到面向编译编译器开发带来的好处（虽然我个人现在还在痛苦当中）。感受前期多用脑子，开发不用脑子的特点了。\n官方文档丰富 官方（社区）为Rust提供了许多优良的文档，比如the book，他们本身的优秀使得你可以从官网快速开始学习Rust。\nRust的缺陷之处 学习曲线陡峭 Rust与C-like语言较大的差异使得上手Rust变得困难。为了严格防止未定义行为，Rust又引入了所有权，生命周期等概念。这使得学习Rust的难度进一步提高。\n编译时间长 为了保证可靠性，Rust需要在编译时进行大量的检查（编译器教你做事），这使得一个大的项目要花费更多的时间在编译上。更为遗憾的是这个缺点可能需要很久（甚至不可能）改善。\n不过现在已经有多线程编译的出现以减少编译时间。\n就算你不致力于使用Rust，也可以看一看Rust Rust吸收了许多编程语言的优良设计，并解决了许多过去编程的痛点问题。就算你不使用Rust，去学一学Rust的哲学也可以帮助你成为更好的程序员。\n","permalink":"http://yl4869.github.io/posts/rust/rust_1/","summary":"Rust介绍 官网对rust的介绍为一门赋予每个人构建可靠且高效软件能力的语言。\nRust是一门系统编程语言。简单来说，系统编程语言是一种资源受限的编程，你需要对每个字节和每个CPU时钟周期精打细算，做到高效的完成任务。\n常见的系统编程应用场景:\n操作系统 各种设备驱动 文件系统 数据库 嵌入式设备 内存管理程序 高级编程语言 虚拟化及软件程序 游戏 等等\u0026hellip; 为什么选择Rust 系统编程语言已经有C/CPP了，为什么我还要选择Rust? C语言诞生于1972年，C++诞生于1979年，这至今41+年的时光中一直没有编程语言去挑战他们的地位。\n由于时代原因，C和C++是两门过于相信程序员的编程语言，不会去检查程序员出错的代码。\nRust的第一个正式版本发布于2015年，融合了现代编程语言的优秀设计，解决了传统系统编程语言的痛点问题。产生了高性能，可靠性，生产力三个优秀特点。\n最值得一提的是可靠性，Rust的设计使得你可以在编译器解决各种错误，而不是运行时。同时他的这种设计也让多核时代的多线程编写变得更加简单。\n又有谁没被segmentation fault折磨过呢？\n享受编程 一旦你学会了rust，你就会享受到面向编译编译器开发带来的好处（虽然我个人现在还在痛苦当中）。感受前期多用脑子，开发不用脑子的特点了。\n官方文档丰富 官方（社区）为Rust提供了许多优良的文档，比如the book，他们本身的优秀使得你可以从官网快速开始学习Rust。\nRust的缺陷之处 学习曲线陡峭 Rust与C-like语言较大的差异使得上手Rust变得困难。为了严格防止未定义行为，Rust又引入了所有权，生命周期等概念。这使得学习Rust的难度进一步提高。\n编译时间长 为了保证可靠性，Rust需要在编译时进行大量的检查（编译器教你做事），这使得一个大的项目要花费更多的时间在编译上。更为遗憾的是这个缺点可能需要很久（甚至不可能）改善。\n不过现在已经有多线程编译的出现以减少编译时间。\n就算你不致力于使用Rust，也可以看一看Rust Rust吸收了许多编程语言的优良设计，并解决了许多过去编程的痛点问题。就算你不使用Rust，去学一学Rust的哲学也可以帮助你成为更好的程序员。","title":"Rust介绍"},{"content":"简介 你可能经常看到.tar与.tar.gz文件，但你可能很少思考过他们的用法。下面将介绍他们的区别\ntar tar是打包命令，可以把一大堆的文件和目录打包成一个文件，方便文件的备份和文件在网络中的传输。\n弄清打包和压缩的概念，打包并不会减小文件的大小。\n当我们想要将多个文件压缩成一个压缩包时，我们需要先对这些文件进行打包，然后再用压缩程序进行压缩。\ngz(误) gz并不是一个正确的说法，事实上你可以单独使用gzip等压缩程序对文件进行压缩，常见的.tar.gz是直接用tar打包并通过应用程序进行压缩的一种方式。\n永远记得一个事实：linux当中后缀名不是必须的，更多是为了便于区别。\n从例子学习使用 tar进行文件打包 1.打包文件\ntar -cf file.tar file1 file2 将file1和file2进行打包。-c表示进行打包，-f指定打包文档(file.tar)\n2.解包文件\ntar -xf file.tar -x表示解包，-f指定解包文档(file.tar)\n压缩文件进行文件压缩 这里只介绍利用gzip压缩软件，事实上还有其他的压缩软件可以使用 1.压缩文件\ngzip file.tar 2.解压文件\ngunzip file.tar.gz 直接利用tar进行打包与解压 1.压缩文件\ntar -czvf file.tar.gz file1 file2 -c,-f已经介绍过。-z表示使用的压缩是gzip压缩，-v表示显示所有过程\n2.解压文件\ntar -xzvf file.tar.gz 现在你应该理解了压缩与解压阶段各种参数的意义。\n注意：-f后面必须接文档名，所以作为最后一个参数\n","permalink":"http://yl4869.github.io/posts/learn_linux/tips/tip1/","summary":"简介 你可能经常看到.tar与.tar.gz文件，但你可能很少思考过他们的用法。下面将介绍他们的区别\ntar tar是打包命令，可以把一大堆的文件和目录打包成一个文件，方便文件的备份和文件在网络中的传输。\n弄清打包和压缩的概念，打包并不会减小文件的大小。\n当我们想要将多个文件压缩成一个压缩包时，我们需要先对这些文件进行打包，然后再用压缩程序进行压缩。\ngz(误) gz并不是一个正确的说法，事实上你可以单独使用gzip等压缩程序对文件进行压缩，常见的.tar.gz是直接用tar打包并通过应用程序进行压缩的一种方式。\n永远记得一个事实：linux当中后缀名不是必须的，更多是为了便于区别。\n从例子学习使用 tar进行文件打包 1.打包文件\ntar -cf file.tar file1 file2 将file1和file2进行打包。-c表示进行打包，-f指定打包文档(file.tar)\n2.解包文件\ntar -xf file.tar -x表示解包，-f指定解包文档(file.tar)\n压缩文件进行文件压缩 这里只介绍利用gzip压缩软件，事实上还有其他的压缩软件可以使用 1.压缩文件\ngzip file.tar 2.解压文件\ngunzip file.tar.gz 直接利用tar进行打包与解压 1.压缩文件\ntar -czvf file.tar.gz file1 file2 -c,-f已经介绍过。-z表示使用的压缩是gzip压缩，-v表示显示所有过程\n2.解压文件\ntar -xzvf file.tar.gz 现在你应该理解了压缩与解压阶段各种参数的意义。\n注意：-f后面必须接文档名，所以作为最后一个参数","title":"Linux小tip------tar与gz"},{"content":"简介 限制想要将工作从windows迁移到linux上的一个方面就是游戏。Steam已经通过proton给到了游戏玩家更多的选择。暴雪尚未出现linux版本，但好在还有wine的存在。通过lutris，现在你可以更轻松地在linux上享受游戏。\n我会尽量给出官方文档，以便于不同时间的不同用户进行操作时可以减少错误。\n操作系统：manjaro\n显卡：Nvidia no-free驱动\n步骤 1.安装合适的Gpu驱动 https://github.com/lutris/docs/blob/master/InstallingDrivers.md\nlutris为我们创建了一个良好的文档说明。你可以选择与你电脑相符的介绍并继续操作。对我的系统manjaro而言，我已经在安装时选择了no-free驱动，因此已经有了一套正确的驱动支持。\n安装wine https://github.com/lutris/docs/blob/master/WineDependencies.md\n同样，选择你的发行版并按步骤进行操作,这里以我的系统manjaro为例。\n修改/etc/pacman.conf,添加[multilib]启动multilib仓库，在文件中添加以下内容：\n/etc/pacman.conf -------------------------------------------------------------------------------------- [multilib] Include = /etc/pacman.d/mirrorlist 更新pacman仓库\nsudo pacman -Syu 安装wine，要安装的包有点多，但其实很多你已经安装过了，全部的依赖安装可以避免之后出现奇奇怪怪的问题。\nsudo pacman -S --needed wine-staging giflib lib32-giflib libpng lib32-libpng libldap lib32-libldap gnutls lib32-gnutls \\ mpg123 lib32-mpg123 openal lib32-openal v4l-utils lib32-v4l-utils libpulse lib32-libpulse libgpg-error \\ lib32-libgpg-error alsa-plugins lib32-alsa-plugins alsa-lib lib32-alsa-lib libjpeg-turbo lib32-libjpeg-turbo \\ sqlite lib32-sqlite libxcomposite lib32-libxcomposite libxinerama lib32-libgcrypt libgcrypt lib32-libxinerama \\ ncurses lib32-ncurses opencl-icd-loader lib32-opencl-icd-loader libxslt lib32-libxslt libva lib32-libva gtk3 \\ lib32-gtk3 gst-plugins-base-libs lib32-gst-plugins-base-libs vulkan-icd-loader lib32-vulkan-icd-loader 以上，wine安装完成。\n安装暴雪战网所需的特殊依赖 暴雪战网是暴雪游戏的启动器，为了成功启动需要安装部分依赖。\nsudo pacman -S lib32-gnutls lib32-libldap lib32-libgpg-error lib32-sqlite lib32-libpulse lib32-alsa-plugins 安装lutris https://lutris.net/downloads/\nlutris让你安装与启动游戏更加简单（非广告）\nsudo pacman -S lutris 下载星际争霸2安装脚本 https://lutris.net/games/starcraft-ii/\n你可以通过脚本实现游戏的安装,安装成功后进入暴雪战网安装游戏。\n开始游戏 安装完成后，你可以开始游戏了，我在游戏启动时会自动识别独显并启动，游戏一局开始2分钟会有小卡顿，但随后十分流畅，整体体验感很不错。\n鸣谢 感谢 https://www.youtube.com/watch?v=Fyjc-c5oN4k\n在我开始时看到了这个视频，并通过视频完成了游戏的安装，使我走了很少的弯路。\n","permalink":"http://yl4869.github.io/posts/learn_linux/starcraftii/","summary":"简介 限制想要将工作从windows迁移到linux上的一个方面就是游戏。Steam已经通过proton给到了游戏玩家更多的选择。暴雪尚未出现linux版本，但好在还有wine的存在。通过lutris，现在你可以更轻松地在linux上享受游戏。\n我会尽量给出官方文档，以便于不同时间的不同用户进行操作时可以减少错误。\n操作系统：manjaro\n显卡：Nvidia no-free驱动\n步骤 1.安装合适的Gpu驱动 https://github.com/lutris/docs/blob/master/InstallingDrivers.md\nlutris为我们创建了一个良好的文档说明。你可以选择与你电脑相符的介绍并继续操作。对我的系统manjaro而言，我已经在安装时选择了no-free驱动，因此已经有了一套正确的驱动支持。\n安装wine https://github.com/lutris/docs/blob/master/WineDependencies.md\n同样，选择你的发行版并按步骤进行操作,这里以我的系统manjaro为例。\n修改/etc/pacman.conf,添加[multilib]启动multilib仓库，在文件中添加以下内容：\n/etc/pacman.conf -------------------------------------------------------------------------------------- [multilib] Include = /etc/pacman.d/mirrorlist 更新pacman仓库\nsudo pacman -Syu 安装wine，要安装的包有点多，但其实很多你已经安装过了，全部的依赖安装可以避免之后出现奇奇怪怪的问题。\nsudo pacman -S --needed wine-staging giflib lib32-giflib libpng lib32-libpng libldap lib32-libldap gnutls lib32-gnutls \\ mpg123 lib32-mpg123 openal lib32-openal v4l-utils lib32-v4l-utils libpulse lib32-libpulse libgpg-error \\ lib32-libgpg-error alsa-plugins lib32-alsa-plugins alsa-lib lib32-alsa-lib libjpeg-turbo lib32-libjpeg-turbo \\ sqlite lib32-sqlite libxcomposite lib32-libxcomposite libxinerama lib32-libgcrypt libgcrypt lib32-libxinerama \\ ncurses lib32-ncurses opencl-icd-loader lib32-opencl-icd-loader libxslt lib32-libxslt libva lib32-libva gtk3 \\ lib32-gtk3 gst-plugins-base-libs lib32-gst-plugins-base-libs vulkan-icd-loader lib32-vulkan-icd-loader 以上，wine安装完成。","title":"在linux上游玩星际争霸2"},{"content":"简介 数据流重定向是将某个指令执行后要输出在屏幕上的数据，传输到其他的地方。一是可以简化我们的屏幕输出， 去获取我们有用的数据。同时我们还可以将我们想要的数据存储下来。\n你可以通过echo \u0026quot;123\u0026quot;和echo \u0026quot;123\u0026quot; \u0026gt; filename 去简单尝试一下这种方式的特点，第二种可以通过 查看新增的file文件观看内容。\n标准输入输出与标准错误输出 基本使用 \u0026gt; 是我们实现这种数据流重导向所用的特殊字符，数据流重导向包括标准输入，标准输出和标准错误输出， 他们的规则如下所示： 名称 代码 符号 标准输入(stdin) 0 \u0026lt;或\u0026laquo; 标准输出(stdout) 1 \u0026gt;或\u0026raquo; 标准错误输出(stderr) 2 2\u0026gt;或2\u0026raquo; \u0026gt; 和 \u0026raquo; 的区别是 \u0026gt; 以覆盖的方法输出内容， \u0026raquo; 则是以累加的方式输出内容。你可以自 己试一试。 标准输入的用法类似，可以尝试一下cat \u0026gt; file 尝试键盘输出，使用[ctrl]+d退出，然后看一下得到的 文件。\n/dev/null 垃圾桶 在linux一切皆文件的哲学中 /dev/null是一个特殊的\u0026quot;装置\u0026quot; 你可以将任何你想忽略的内容导向到它，而这些 内容将彻底被丢弃。\n特殊写法 如果我们想要将正确与错误数据写入同一个文件时，可能会发生数据交叉写入该文件内的情况，造成次序的错乱， 这个时候你可以使用 2\u0026gt;\u0026amp;1 和 \u0026amp;\u0026gt; 的语法。\nfind /home -name .bashrc \u0026gt; list 2\u0026gt; list \u0026lt;=错误 find /home -name .bashrc \u0026gt; list 2\u0026amp;\u0026gt;1 \u0026lt;=正确 find /home -name .bashrc \u0026amp;\u0026gt; list \u0026lt;=正确 2\u0026gt;\u0026amp;1 这种写法可以理解为将标准错误输出重定向到标准输出\n\u0026amp;\u0026gt;file 这种写法可以理解为将标准输入和输出都重定向到文件file中\nls 2\u0026gt;1 测试一下，不会报没有2文件的错误，但会输出一个空的文件1；\nls xxx 2\u0026gt;1测试，没有xxx这个文件的错误输出到了1中；\nls xxx 2\u0026gt;\u0026amp;1测试，不会生成1这个文件了，不过错误跑到标准输出了；\nls xxx \u0026gt;out.txt 2\u0026gt;\u0026amp;1, 实际上可换成 ls xxx 1\u0026gt;out.txt 2\u0026gt;\u0026amp;1；重定向符号\u0026gt;默认是1,错误和输出都传到out.txt了。\n","permalink":"http://yl4869.github.io/posts/learn_linux/standard_input_output/","summary":"简介 数据流重定向是将某个指令执行后要输出在屏幕上的数据，传输到其他的地方。一是可以简化我们的屏幕输出， 去获取我们有用的数据。同时我们还可以将我们想要的数据存储下来。\n你可以通过echo \u0026quot;123\u0026quot;和echo \u0026quot;123\u0026quot; \u0026gt; filename 去简单尝试一下这种方式的特点，第二种可以通过 查看新增的file文件观看内容。\n标准输入输出与标准错误输出 基本使用 \u0026gt; 是我们实现这种数据流重导向所用的特殊字符，数据流重导向包括标准输入，标准输出和标准错误输出， 他们的规则如下所示： 名称 代码 符号 标准输入(stdin) 0 \u0026lt;或\u0026laquo; 标准输出(stdout) 1 \u0026gt;或\u0026raquo; 标准错误输出(stderr) 2 2\u0026gt;或2\u0026raquo; \u0026gt; 和 \u0026raquo; 的区别是 \u0026gt; 以覆盖的方法输出内容， \u0026raquo; 则是以累加的方式输出内容。你可以自 己试一试。 标准输入的用法类似，可以尝试一下cat \u0026gt; file 尝试键盘输出，使用[ctrl]+d退出，然后看一下得到的 文件。\n/dev/null 垃圾桶 在linux一切皆文件的哲学中 /dev/null是一个特殊的\u0026quot;装置\u0026quot; 你可以将任何你想忽略的内容导向到它，而这些 内容将彻底被丢弃。\n特殊写法 如果我们想要将正确与错误数据写入同一个文件时，可能会发生数据交叉写入该文件内的情况，造成次序的错乱， 这个时候你可以使用 2\u0026gt;\u0026amp;1 和 \u0026amp;\u0026gt; 的语法。\nfind /home -name .bashrc \u0026gt; list 2\u0026gt; list \u0026lt;=错误 find /home -name .bashrc \u0026gt; list 2\u0026amp;\u0026gt;1 \u0026lt;=正确 find /home -name .","title":"数据流重定向"},{"content":"整理了一些平时优质的学习网站，做出分享，长期更新。\n各种工具类 一个全栈工程师的工具箱 http://toolbox.phodal.com/\n顾名思义，从文档到工具到外设，在无聊的时候可以随意看一看，说不定就找到了提升自己生产力的工具。\nLaTex https://www.overleaf.com/\nLaTex在线编辑工具\ngodbolt https://godbolt.org/\n高级语言到汇编的在线转换工具\nFPGA FPGA使用笔记 https://www.kancloud.cn/dlover/fpga\n记录了作者学习FPGA时的各种积累，适合新手学习。\n机器学习 ###机器学习数据寻找\nhttps://www.zhihu.com/question/342295029/answer/846359794\n画出美观的神经网络 http://alexlenail.me/NN-SVG/LeNet.html\n前端 前端背景 https://www.pexels.com/zh-cn/\n免费高清矢量图片\n","permalink":"http://yl4869.github.io/posts/day_day_up/","summary":"整理了一些平时优质的学习网站，做出分享，长期更新。\n各种工具类 一个全栈工程师的工具箱 http://toolbox.phodal.com/\n顾名思义，从文档到工具到外设，在无聊的时候可以随意看一看，说不定就找到了提升自己生产力的工具。\nLaTex https://www.overleaf.com/\nLaTex在线编辑工具\ngodbolt https://godbolt.org/\n高级语言到汇编的在线转换工具\nFPGA FPGA使用笔记 https://www.kancloud.cn/dlover/fpga\n记录了作者学习FPGA时的各种积累，适合新手学习。\n机器学习 ###机器学习数据寻找\nhttps://www.zhihu.com/question/342295029/answer/846359794\n画出美观的神经网络 http://alexlenail.me/NN-SVG/LeNet.html\n前端 前端背景 https://www.pexels.com/zh-cn/\n免费高清矢量图片","title":"各种资源网站分享"},{"content":"引言 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n与通配符(如*)类似，正则表达式也是用来进行文本匹配的工具，不过他要更为精确和复杂。学习正则表达式的最好办法就是利用例子学习。\n元字符 现在考虑从英文小说里查找hi，你可以使用正则表达式hi,但这样的代价是你会查找到文本中所有有hi的位置,而不是一个单词。为了查找到一个单词你可以使用\\bhi\\b,他会帮你匹配单词hi存在的位置。\n\\b是正则表达式中元字符(metacharacter),代表单词的分界处，但请注意\\b并不匹配用来分界单词的字符(如空格，标点或者换行符)，他匹配的是一个位置。\n更为精确的说法是：\\b匹配一个前一个字符和后一个字符不全是\\w的位置。\n这样的元字符在正则表达式中有很多，他们帮助构建了正则表达式强大的匹配能力。你不需要全部记住，可以在使用中进行查阅，并在实践中掌握他们。\n如果你要寻找这样的一个字符串：A单词后面跟着一个B单词，AB中间可以有任意字符存在。可以使用\\bA\\b.*\\bB\\b。\n这里的.和\\*也是两个其他的元字符。.可以匹配除了换行符之外的任何字符，而*比较特殊，他使得前面的内容可以连续重复使用任意次来匹配字符串。\n如果你学过离散数学或者计算理论，应该对*不会太过陌生(尤其是学过计算理论)，之后你还会看到+元字符，他们的区别和你在离散数学中他们的区别相同。\n下面给出常见的元字符，和使用他们的一些例子 元字符 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 现在我们可以回顾一下\\b的精确描述，理解\\w的存在。\n例子 \\ba\\w+\\b 匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母 a，然后中间至少有一个字母或者数字(\\w+)，最后是单词结束处(\\b)。用到了\\w与+的共同使用,*可以有0，但+至少一个。\n\\b\\w{6}\\b 匹配刚好六个字符的单词\n^\\d{5,12}$ ^ 和 $保证了是整个字符串的匹配，而不是字串，{5，12}代表重复的次数不能少于5次，不能多于12次，否则都不匹配。\n","permalink":"http://yl4869.github.io/posts/regularexpressionin/first/","summary":"引言 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n与通配符(如*)类似，正则表达式也是用来进行文本匹配的工具，不过他要更为精确和复杂。学习正则表达式的最好办法就是利用例子学习。\n元字符 现在考虑从英文小说里查找hi，你可以使用正则表达式hi,但这样的代价是你会查找到文本中所有有hi的位置,而不是一个单词。为了查找到一个单词你可以使用\\bhi\\b,他会帮你匹配单词hi存在的位置。\n\\b是正则表达式中元字符(metacharacter),代表单词的分界处，但请注意\\b并不匹配用来分界单词的字符(如空格，标点或者换行符)，他匹配的是一个位置。\n更为精确的说法是：\\b匹配一个前一个字符和后一个字符不全是\\w的位置。\n这样的元字符在正则表达式中有很多，他们帮助构建了正则表达式强大的匹配能力。你不需要全部记住，可以在使用中进行查阅，并在实践中掌握他们。\n如果你要寻找这样的一个字符串：A单词后面跟着一个B单词，AB中间可以有任意字符存在。可以使用\\bA\\b.*\\bB\\b。\n这里的.和\\*也是两个其他的元字符。.可以匹配除了换行符之外的任何字符，而*比较特殊，他使得前面的内容可以连续重复使用任意次来匹配字符串。\n如果你学过离散数学或者计算理论，应该对*不会太过陌生(尤其是学过计算理论)，之后你还会看到+元字符，他们的区别和你在离散数学中他们的区别相同。\n下面给出常见的元字符，和使用他们的一些例子 元字符 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 现在我们可以回顾一下\\b的精确描述，理解\\w的存在。\n例子 \\ba\\w+\\b 匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母 a，然后中间至少有一个字母或者数字(\\w+)，最后是单词结束处(\\b)。用到了\\w与+的共同使用,*可以有0，但+至少一个。\n\\b\\w{6}\\b 匹配刚好六个字符的单词\n^\\d{5,12}$ ^ 和 $保证了是整个字符串的匹配，而不是字串，{5，12}代表重复的次数不能少于5次，不能多于12次，否则都不匹配。","title":"上手正则表达式(一)"},{"content":"CSAPP:Data Lab 记录 bitXor(x,y)\n使用两种运算实现异或操作（\u0026amp;与～），要求指令数最多为14\n//1 /* * bitXor - x^y using only ~ and \u0026amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026amp; * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { int nx = ~x; int ny = ~y; int fx = x \u0026amp; ny; int fy = nx \u0026amp; y; return ~( (~fx) \u0026amp; (~fy) ); } 采用的是离散数学中亦或的另一种定义方式,$$P \\oplus Q = (P \\wedge \\neg Q) \\vee (\\neg P \\vee Q)$$.由于本题中不能直接实现或运算，所以通过非和与实现\ntmin(void)\n返回二进制补码integer的最小值，允许使用！，～，\u0026amp;，^,|,+操作符\n/* * tmin - return minimum two\u0026#39;s complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u0026lt;\u0026lt; 31; } 本题实现十分简单，int型本身以补码32位形式表示，所以只要将1移动到最高位就可以（左移31）\nisTmax(int x)\n给定一个数，如果是maxium，返回1，否则返回0，允许使用！，～，\u0026amp;，^,|,+运算符\n//2 /* * isTmax - returns 1 if x is the maximum, two\u0026#39;s complement number, * and 0 otherwise * Legal ops: ! ~ \u0026amp; ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { int a = x + 1; int b = ~a; return !(b ^ x) \u0026amp; !!a; } 本题实现用了些小技巧，考虑到补码的不对称性与异或运算的逆元特性。Tmax+1 = Tmin; ~Tmin = Tmax;\n同时还要考虑ｘ的特殊情况：x为-1时(a为０时)。\nallOddBits(int x)\n如果x的奇数位上全为1，则返回1，否则返回0，允许使用！，～，\u0026amp;,^,|,+,|,\u0026laquo;,\u0026raquo;\n/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 2 */ int allOddBits(int x) { int a = (0xAA \u0026lt;\u0026lt; 24) + (0xAA \u0026lt;\u0026lt; 16) + (0xAA \u0026lt;\u0026lt; 8) + 0xAA; int b = a \u0026amp; x; return !(b ^ a); } 这些问题首先要确定最后需要返回的是1，所以我倾向于用！运算完成（只会有0，1两种取值，而位运算可能有多种结果），由由我们只可以使用最大0xff的常数，但我们可以移位啊！所以我们可以构造一个0xAAAAAAAA，并且与x相与（完成一个掩码的运算，只留下奇数位）。这个时候得到的值要么是可以判断的0xAAAAAAAA，要么是其他不满足条件的值，通过与我们构造的0xAAAAAAAA进行异或运算，我们可以完成对x的奇数位上是否全为1的判断。\nnegate(int x)\n返回一个数的相反数，允许使用！，～，\u0026amp;,^,|,+,\u0026laquo;,\u0026raquo;\n/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x + 1; } 这道题就十分简单了，运用取反加1的操作可以直接得到结果\nisAsciiDigit(int x)\n判断x是否在ASCII码范围内（0x30 - 0x39） 允许使用 ！，～，\u0026amp;，^,|,+,\u0026laquo;,\u0026raquo;\nint isAsciiDigit(int x) { int a = x | 0x30; int b = ( (x + 0x6) \u0026amp; 0xf ) | 0x30; return !(b^(x+0x6)) \u0026amp; !(a^x); } 本题给出了十六进制，我们也可以直接用十六进制进行比较。利用布尔代数中的逆元（a^a = 0)。\n首先判断下界：通过a ^ x: a由x|0x30完成，此时a满足a \u0026gt;= 0x30\n之后考虑上界，运用类似的思想，我们可以利用进位，当x+0x6发生进位时，我们可以认为x的第一位（右数）是大于0x9的或者第二位是大于0x3的，通过与和或运算，我们将b变回一个发生溢出时成为0x3？的状态。此时与（x+0x6）相异或，就可以判断出是否满足上界了。\nconditional( int x, int y, int z )\n实现三目运算符，x ? y : z; 允许使用!,~,$,^,|,+,\u0026laquo;,\u0026raquo;\nint conditional(int x, int y, int z) { int a = !!x + ~1 + 1; int b = !!!x + ~1 + 1; int zz = a \u0026amp; z; int yy = b \u0026amp; y; return zz | yy; } 通过两次!运算，我们可以将一个int型转换成布尔型（伪），-1 \u0026amp; x = x 利用这个特性我们可以判断ｘ为１时，选择ｙ\u0026amp;-1,x为０时，选择ｚ\u0026amp; -1.\nisLessOrEqual(int x,int y)\n判断x是否小于等于y，满足返回1，否则返回0.允许使用!,~,\u0026amp;,^,|,+,\u0026laquo;,\u0026raquo;\nint isLessOrEqual(int x, int y) { int a = ( x \u0026gt;\u0026gt; 31 ) \u0026amp; 0x1; int b = ( y \u0026gt;\u0026gt; 31 ) \u0026amp; 0x1; int c = a ^ b; int d = c \u0026amp; a; int ll = ~(1 \u0026lt;\u0026lt; 31) ; int m = x \u0026amp; ll; int n = y \u0026amp; ll; int k = m + ~n + 1; int s = ( k \u0026gt;\u0026gt; 31 ) \u0026amp; 0x1; int ans = !!k \u0026amp; !s ; return d | ( !c \u0026amp; !ans ) ; } 简单思考，我们将符号位与后31位进行分离。d决定是否异号并且x小于0，c为0时说明同号，c为1时说明异号。s判断m-n时的正负。这样我们可以知道。ans为1时，m-n大于等于0.判定小于等于零的两个方式，第一种时异号a小于零。第二种是同号m-n大于等于0.\nlogicalNeg(int x)\n实现!运算符，允许使用~,\u0026amp;,^,|,+,\u0026laquo;,\u0026raquo;\nint logicalNeg(int x) { int a = x \u0026gt;\u0026gt; 31; int b = (~x + 1) \u0026gt;\u0026gt; 31; int c = a | b; int d = c + 1; return d \u0026amp; 0x1; } 利用了0的特点，除了+0和-0都是0，而对于其他值，通过两种异号数的移位可以得到c为-1，则d为0.\nhowManyBits(int x) 计算至少需要多少位才能表达x。允许使用!,~,\u0026amp;,^,|,+,\u0026laquo;,\u0026raquo;\nint howManyBits(int x) { int b16,b8,b4,b2,b1,b0; int sign = x \u0026gt;\u0026gt; 31; x = (~sign \u0026amp; x) | (sign \u0026amp; ~x); b16 = !!(x \u0026gt;\u0026gt; 16) \u0026lt;\u0026lt; 4; x = x \u0026gt;\u0026gt; b16; b8 = !!(x \u0026gt;\u0026gt; 8) \u0026lt;\u0026lt; 3; x = x \u0026gt;\u0026gt; b8; b4 = !!(x \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 2; x = x \u0026gt;\u0026gt; b4; b2 = !!(x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 1; x = x \u0026gt;\u0026gt; b2; b1 = !!(x \u0026gt;\u0026gt; 1); x = x \u0026gt;\u0026gt; b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1; } 注意是补码表示，所以需要一位补码的符号位存在，即便是正数。之后就可以考虑用多少位表示。x为正数的话，直接进行计数，x为负数的话，需要计算的就是最靠近符号位的第一个0开始的位数（回忆补码的算数右移）。因此通过对x进行取反可以找到那个1，然后再通过16，8，4，2，1，的方式进行计数。\nfloatScale2(signed uf)\n返回2*f的位表示，算是啥都允许使用了注意NaN是直接返回的 unsigned floatScale2(unsigned uf) { int sign = (uf \u0026gt;\u0026gt; 31) \u0026lt;\u0026lt; 31; int exp = (uf \u0026gt;\u0026gt; 23) \u0026amp; 0xff; if(exp == 0) return sign | (uf \u0026lt;\u0026lt; 1); if(exp == 255) return uf; if(exp + 1 == 255) return sign | 0x7f800000; exp = exp + 1; return ( uf \u0026amp; 0x007fffff) | (exp \u0026lt;\u0026lt; 23) | sign; } 将sign，exp分离出来，（frac直接在后面可以直接操作）；exp为0时，直接uf左移一位完成运算（添加符号位）。exp为255则为，Inf和NaN都返回本身，因此exp全为1时直接返回，同样，如果乘2后exp全为1时，返回Inf。之后就正常进行运算和exp+1后进行组合就好。\nfloatFloat2Int(unsigned uf)\n将浮点数转换为整数 int floatFloat2Int(unsigned uf) { int sign = uf \u0026gt;\u0026gt; 31; int exp = (uf \u0026gt;\u0026gt; 23) \u0026amp; 0xff; int frac = uf \u0026amp; 0x7fffff; int e_b = exp - 127; if(e_b \u0026lt; 0) return 0; if(e_b \u0026gt; 31) return 0x80000000u; int a = 1 \u0026lt;\u0026lt; e_b; int b = frac \u0026gt;\u0026gt; (23 - e_b); int ans = a + b; if(sign == 1) return ~ans + 1; else return ans; } 当溢出时返回给定的溢出值0x80000000u,这里需要考虑exp位进行bias偏移后的值，当e_b \u0026lt; 0时，就是0，当e_b大于31时，说明溢出。浮点的计算方式是通过2^e * M,而本身就是整数，所以对小数部分计算的是反向移位。\nfloatPower2(int x)\n求2.0^x unsigned floatPower2(int x) { int INF = 0xff \u0026lt;\u0026lt; 23; int exp = x + 127; if(exp \u0026lt;= 0) return 0; if(exp \u0026gt;= 255) return INF; return exp \u0026lt;\u0026lt; 23; } 2.0的位级表示是（1.0 * 2^1):可以考虑到符号位是0，指数为1+127=128;frac=1.0-1=0; 这样这道题就显而易见了。依旧考虑exp+bias的情况。\n总结 一定要自己亲自做一次 多反思，多总结 多翻书，知识点很多都在书里 ","permalink":"http://yl4869.github.io/posts/csapp/datalab/","summary":"CSAPP:Data Lab 记录 bitXor(x,y)\n使用两种运算实现异或操作（\u0026amp;与～），要求指令数最多为14\n//1 /* * bitXor - x^y using only ~ and \u0026amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026amp; * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { int nx = ~x; int ny = ~y; int fx = x \u0026amp; ny; int fy = nx \u0026amp; y; return ~( (~fx) \u0026amp; (~fy) ); } 采用的是离散数学中亦或的另一种定义方式,$$P \\oplus Q = (P \\wedge \\neg Q) \\vee (\\neg P \\vee Q)$$.","title":"Datalab实验记录"},{"content":"前言 编程语言的类型模型（type model）一直都是编程语言学习的重点。虽然但是，C语言声明的语法实在是过于奇怪，以至于我们需要花费一些时间认真理解一下，首先思考一下简单的类型模型,考虑下面的C语言声明:\ntypedef char * string; string punchline = \u0026#34;I\u0026#39;m a frayed knot\u0026#34;; 可以将其分为两部分：变量的类型和变量来理解\n被称作 是 变量的类型 string char * 变量 punchline \u0026ldquo;I;m a frayed knot\u0026rdquo; C语言声明的产生 C语言中的声明器（declarator） 简单地说，声明器就是标识符以及和他组合在一起的任何指针、函数符号、数组下标（本表额外添加了初始化内容）\n数量 C语言中的名字 C语言中出现的形式 零个或多个 指针 const volatile;volatile;; const; * volatile const 有且只有一个 直接声明器 标识符;标识符[下标];标识符(参数);(声明器) 零个或一个 初始化内容 = 初始值 声明器是一个很模糊的概念，一个简单的思考方式是C语言的声明器是声明中缺少类型以及对类型限定后剩下的部分，这也可以理解 int *p,*q,r 都是什么类型了（p，q是指针，r是int型变量）\nC语言的声明 声明增加了至少一个类型说明符（包括类型说明，存储说明和类型限定符），声明器（一个或多个，逗号分割）分号（语句结束）但也请注意，合法的声明存在限定条件，举例说明：\n函数的返回值不能是一个函数，所以 foo()() 是非法的 函数的返回值不能是一个数组，所以 foo()[] 是非法的 数组里面不能有函数，所以 foo 是非法的 你也许很快想到，针对这些问题可以用指针解决，所以\n函数的返回值允许是一个函数指针，如 int(* fun()) () 函数的返回值允许是一个指向数组的指针， 如 int(*foo())[] 数组里面允许有函数指针 如 int (*foo[])() 数组里面允许有其他数组，所以你经常看到 int foo[][] 优先级规则 C语言声明的优先级规则是阅读C语言声明关键的一步：因为C语言的声明并不是简单的从左到右，下面给出这条规则\nA 声明从它的名字开始读取，然后按照优先级顺序依次读取；\nB 优先级从高到低依次是：\nB.1 声明中被括号括起来的那部分；\nB.2 后缀操作符：括号()表示这是一个函数，而方括号[]表示这是一个数组；\nB.3 前缀操作符：星号*标识“指向\u0026hellip;的指针”；\nC 如果const和(或者)volatile关键字的后面紧跟类型说明符(如int，long等)，那么它作用于类型说明符，在其他情况下，const和(或)volatile关键字作用于它左边紧邻的指针星号。\n分析一个例子：\nchar * const * (*next) ();\nA 首先，确定变量名next\nB.1 将括号看成整体，得出next是一个指向..的指针\nB.2 考虑括号外面，后缀 () 得出next是一个函数指针，指向一个返回\u0026hellip;的函数\nB.3 然后，处理前缀 * ，得出函数返回的是另一个指针\nC 将 char * const 解释为指向字符的常量指针\n得出结论：next是一个指针，它指向一个函数，函数返回另一个指针，返回的指针是一个类型为char的常量指针\n对于const,一个方便的理解方法是const默认修饰左边的,否则作用于右边,因此我们可以看到__char * const__是一个char类型的常量指针.给出几个const的例子\n语法 含义 const T* 指向const对象的指针 T const * 指向const对象的指针 T * const 指向对象的cosnt指针 const T* const 指向const对象的const指针 T const * const 指向const对象的const指针 ","permalink":"http://yl4869.github.io/posts/learn_c_cpp/declarations/","summary":"前言 编程语言的类型模型（type model）一直都是编程语言学习的重点。虽然但是，C语言声明的语法实在是过于奇怪，以至于我们需要花费一些时间认真理解一下，首先思考一下简单的类型模型,考虑下面的C语言声明:\ntypedef char * string; string punchline = \u0026#34;I\u0026#39;m a frayed knot\u0026#34;; 可以将其分为两部分：变量的类型和变量来理解\n被称作 是 变量的类型 string char * 变量 punchline \u0026ldquo;I;m a frayed knot\u0026rdquo; C语言声明的产生 C语言中的声明器（declarator） 简单地说，声明器就是标识符以及和他组合在一起的任何指针、函数符号、数组下标（本表额外添加了初始化内容）\n数量 C语言中的名字 C语言中出现的形式 零个或多个 指针 const volatile;volatile;; const; * volatile const 有且只有一个 直接声明器 标识符;标识符[下标];标识符(参数);(声明器) 零个或一个 初始化内容 = 初始值 声明器是一个很模糊的概念，一个简单的思考方式是C语言的声明器是声明中缺少类型以及对类型限定后剩下的部分，这也可以理解 int *p,*q,r 都是什么类型了（p，q是指针，r是int型变量）\nC语言的声明 声明增加了至少一个类型说明符（包括类型说明，存储说明和类型限定符），声明器（一个或多个，逗号分割）分号（语句结束）但也请注意，合法的声明存在限定条件，举例说明：\n函数的返回值不能是一个函数，所以 foo()() 是非法的 函数的返回值不能是一个数组，所以 foo()[] 是非法的 数组里面不能有函数，所以 foo 是非法的 你也许很快想到，针对这些问题可以用指针解决，所以\n函数的返回值允许是一个函数指针，如 int(* fun()) () 函数的返回值允许是一个指向数组的指针， 如 int(*foo())[] 数组里面允许有函数指针 如 int (*foo[])() 数组里面允许有其他数组，所以你经常看到 int foo[][] 优先级规则 C语言声明的优先级规则是阅读C语言声明关键的一步：因为C语言的声明并不是简单的从左到右，下面给出这条规则","title":"C语言的声明"},{"content":"前言 C++有四种显式类型转换方法，分别是dynamic_cast, reinterpret_cast, static_cast, const_cast。\n他们的使用方法为\ndynamic_cast \u0026lt;new_type\u0026gt; (expression) reinterpret_cast \u0026lt;new_type\u0026gt; (expression) static_cast \u0026lt;new_type\u0026gt; (expression) const_cast \u0026lt;new_type\u0026gt; (expression) 与之相对，我们也回忆一下传统的类型转换方法\n(new_type) expression new_type (expression) 下面就四种类型转换进行简单介绍。\ndynamic_cast 有需要提前指出的是，dynamic_cast运算符更多是用来实现RTTI（运行时类型识别 run-time type identification） 功能,其中dynamic_cast用来将基类的指针或引用安全地转移成派生类的指针或引用。\n使用RTTI时必须加倍小心，更多时候最好定义虚函数，使用时程序员必须清楚地知道转换的目标模型并且必须检查类型转换是否被成功执行。\ndynamic_cast只用在指向类的指针，引用（或void *)上。这种转换允许upcast（从派生类向基类的转换）也能downcast（从基类向派生类的转换），这时需要转过去的指针所指向的目标有效且完整。\n举例说明\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;exception\u0026gt; using namespace std; class Base {virtual void dummy() {} }; class Derived : public Base { int a; }; int main() { try { Base * pba = new Derived; Base * pbb = new Base; Derived * pd; pd = dynamic_cast\u0026lt;Derived*\u0026gt;(pba); if( pd == 0 ) cout \u0026lt;\u0026lt; \u0026#34;Null pointer on first type-case.\\n\u0026#34;; pd = dynamic_cast\u0026lt;Derived*\u0026gt;(pbb); if( pd == 0 ) cout \u0026lt;\u0026lt; \u0026#34;Null pointer on second type-cast.\\n\u0026#34;; } catch ( exception\u0026amp; e ) { cout \u0026lt;\u0026lt; \u0026#34;Exception: \u0026#34; \u0026lt;\u0026lt; e.what(); } return 0; } 输出：\nNull Pointer on second type-cast 这里做一个解释，当dynamic_cast语句的转换目标为指针并且失败时，结果为0，如果转换目标是引用并且失败了，则dynamic_cast会抛出一个bad_cast异常。\n类型转换可以成功的要求：被转换类型是目标new type的公有派生类，公有基类或者就是目标类型new type的类型,同时保证被转换类型具有目标类型的完整信息（父类到子类时，父类指针真实的指向了对应的子类类型，则转换可以成功。否则，转换失败。\n可见第二次转换无法成功的原因时pbb指向了基类Base，对派生类Derived而言是不完整的。\nstatic_cast static_cast可以用作普通类型转换以及类的upcast，downcast转换，值得注意的是它并不会有运行时检查来保证转换的有效和完整，这完全依靠程序员来确保，因此有可能发生running error\nreinterpret_cast 正如名字所说，reinterpret_cast对指针指向的二进制块进行一个重新解释，也并不会考虑安全性的问题，下面以代码为例。\n#include\u0026lt;iostream\u0026gt; using namespace std; int main() { int num = 0x00646566; int * pnum = \u0026amp;num; char * pstr = reinterpret_cast\u0026lt;char *\u0026gt;(pnum); cout \u0026lt;\u0026lt; pnum \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; static_cast\u0026lt;void *\u0026gt;(pstr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; *pnum \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pstr \u0026lt;\u0026lt; endl; return 0; } 输出：\n0x7ffc0fce6224 0x7ffc0fce6224 646566 fed 可见reinterpret_cast改变了解释文件的方式，但并没有改变其他的东西，但要注意这可能是危险的。 关于为什么会反向输出fed而不是def，挖个坑下次填。\nconst_cast const_cast用于取出对变量的const或volatile限定，转换后指针指向原来的变量，指针地址不改变。\n也就是说，我们可以利用这种方式通过转换去除const进行对const变量的修改。\n注意，这是十分危险的行为，我们不建议这样做，只有当你真的需要用到去除const这种要求的时候才能这样。\n","permalink":"http://yl4869.github.io/posts/learn_c_cpp/type_coversions_cast/","summary":"前言 C++有四种显式类型转换方法，分别是dynamic_cast, reinterpret_cast, static_cast, const_cast。\n他们的使用方法为\ndynamic_cast \u0026lt;new_type\u0026gt; (expression) reinterpret_cast \u0026lt;new_type\u0026gt; (expression) static_cast \u0026lt;new_type\u0026gt; (expression) const_cast \u0026lt;new_type\u0026gt; (expression) 与之相对，我们也回忆一下传统的类型转换方法\n(new_type) expression new_type (expression) 下面就四种类型转换进行简单介绍。\ndynamic_cast 有需要提前指出的是，dynamic_cast运算符更多是用来实现RTTI（运行时类型识别 run-time type identification） 功能,其中dynamic_cast用来将基类的指针或引用安全地转移成派生类的指针或引用。\n使用RTTI时必须加倍小心，更多时候最好定义虚函数，使用时程序员必须清楚地知道转换的目标模型并且必须检查类型转换是否被成功执行。\ndynamic_cast只用在指向类的指针，引用（或void *)上。这种转换允许upcast（从派生类向基类的转换）也能downcast（从基类向派生类的转换），这时需要转过去的指针所指向的目标有效且完整。\n举例说明\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;exception\u0026gt; using namespace std; class Base {virtual void dummy() {} }; class Derived : public Base { int a; }; int main() { try { Base * pba = new Derived; Base * pbb = new Base; Derived * pd; pd = dynamic_cast\u0026lt;Derived*\u0026gt;(pba); if( pd == 0 ) cout \u0026lt;\u0026lt; \u0026#34;Null pointer on first type-case.","title":"C++下的四种cast转换方法"}]
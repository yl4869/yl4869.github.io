<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>linux on FunForever</title>
    <link>http://yl4869.github.io/tags/linux/</link>
    <description>Recent content in linux on FunForever</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 Dec 2022 19:29:17 +0800</lastBuildDate><atom:link href="http://yl4869.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>新硬盘挂载后发现 df 查询大小和实际大小不一致--Linux的保留空间</title>
      <link>http://yl4869.github.io/posts/learn_linux/reserved_space/</link>
      <pubDate>Thu, 08 Dec 2022 19:29:17 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/reserved_space/</guid>
      <description>前言 在 Linux 上安装一块新硬盘后，发现硬盘大小和挂载后查询到的大小不一致，大概差了 5% 左右，一种可能就是硬盘分区是留下的保留空间造成的。
细节 mkfs.ext4 的man page提供了一部分的解释。
Specify the percentage of the filesystem blocks reserved for the super-user. This avoids fragmentation, and allows root-owned daemons, such as syslogd(8), to continue to function correctly after non-privileged processes are prevented from writing to the filesystem. The default percentage is 5%.
简单来说，ext文件系统为了保证在硬盘百分百利用下还能够写入 root 用户的关键日志等信息，默认预留了5%的磁盘空间。
但我们可以发现，这部分空间很多时候是不需要预留的，尤其是在大的磁盘分区下（例如NAS），可能会导致大量空间的浪费。
解决 针对这个问题，也已经有了解决方案。可以通过tune2fs命令查看保留空间大小和设置保留空间。
tune2fs -l /dev/sde1 | egrep &amp;#34;Block size:|Reserved block count&amp;#34; # Reserved block count: 36628312 # Block size: 4096 # set the reserved space 1% tune2fs -m 1 /dev/sde1 Reference Decrease Reserve Space</description>
    </item>
    
    <item>
      <title>Linux小tip------tar与gz</title>
      <link>http://yl4869.github.io/posts/learn_linux/tips/tip1/</link>
      <pubDate>Mon, 14 Feb 2022 21:15:57 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/tips/tip1/</guid>
      <description>简介 你可能经常看到.tar与.tar.gz文件，但你可能很少思考过他们的用法。下面将介绍他们的区别
tar tar是打包命令，可以把一大堆的文件和目录打包成一个文件，方便文件的备份和文件在网络中的传输。
弄清打包和压缩的概念，打包并不会减小文件的大小。
当我们想要将多个文件压缩成一个压缩包时，我们需要先对这些文件进行打包，然后再用压缩程序进行压缩。
gz(误) gz并不是一个正确的说法，事实上你可以单独使用gzip等压缩程序对文件进行压缩，常见的.tar.gz是直接用tar打包并通过应用程序进行压缩的一种方式。
永远记得一个事实：linux当中后缀名不是必须的，更多是为了便于区别。
从例子学习使用 tar进行文件打包 1.打包文件
tar -cf file.tar file1 file2 将file1和file2进行打包。-c表示进行打包，-f指定打包文档(file.tar)
2.解包文件
tar -xf file.tar -x表示解包，-f指定解包文档(file.tar)
压缩文件进行文件压缩 这里只介绍利用gzip压缩软件，事实上还有其他的压缩软件可以使用 1.压缩文件
gzip file.tar 2.解压文件
gunzip file.tar.gz 直接利用tar进行打包与解压 1.压缩文件
tar -czvf file.tar.gz file1 file2 -c,-f已经介绍过。-z表示使用的压缩是gzip压缩，-v表示显示所有过程
2.解压文件
tar -xzvf file.tar.gz 现在你应该理解了压缩与解压阶段各种参数的意义。
注意：-f后面必须接文档名，所以作为最后一个参数</description>
    </item>
    
    <item>
      <title>在linux上游玩星际争霸2</title>
      <link>http://yl4869.github.io/posts/learn_linux/starcraftii/</link>
      <pubDate>Sun, 23 Jan 2022 23:42:33 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/starcraftii/</guid>
      <description>简介 限制想要将工作从windows迁移到linux上的一个方面就是游戏。Steam已经通过proton给到了游戏玩家更多的选择。暴雪尚未出现linux版本，但好在还有wine的存在。通过lutris，现在你可以更轻松地在linux上享受游戏。
我会尽量给出官方文档，以便于不同时间的不同用户进行操作时可以减少错误。
操作系统：manjaro
显卡：Nvidia no-free驱动
步骤 1.安装合适的Gpu驱动 https://github.com/lutris/docs/blob/master/InstallingDrivers.md
lutris为我们创建了一个良好的文档说明。你可以选择与你电脑相符的介绍并继续操作。对我的系统manjaro而言，我已经在安装时选择了no-free驱动，因此已经有了一套正确的驱动支持。
安装wine https://github.com/lutris/docs/blob/master/WineDependencies.md
同样，选择你的发行版并按步骤进行操作,这里以我的系统manjaro为例。
修改/etc/pacman.conf,添加[multilib]启动multilib仓库，在文件中添加以下内容：
/etc/pacman.conf -------------------------------------------------------------------------------------- [multilib] Include = /etc/pacman.d/mirrorlist 更新pacman仓库
sudo pacman -Syu 安装wine，要安装的包有点多，但其实很多你已经安装过了，全部的依赖安装可以避免之后出现奇奇怪怪的问题。
sudo pacman -S --needed wine-staging giflib lib32-giflib libpng lib32-libpng libldap lib32-libldap gnutls lib32-gnutls \ mpg123 lib32-mpg123 openal lib32-openal v4l-utils lib32-v4l-utils libpulse lib32-libpulse libgpg-error \ lib32-libgpg-error alsa-plugins lib32-alsa-plugins alsa-lib lib32-alsa-lib libjpeg-turbo lib32-libjpeg-turbo \ sqlite lib32-sqlite libxcomposite lib32-libxcomposite libxinerama lib32-libgcrypt libgcrypt lib32-libxinerama \ ncurses lib32-ncurses opencl-icd-loader lib32-opencl-icd-loader libxslt lib32-libxslt libva lib32-libva gtk3 \ lib32-gtk3 gst-plugins-base-libs lib32-gst-plugins-base-libs vulkan-icd-loader lib32-vulkan-icd-loader 以上，wine安装完成。</description>
    </item>
    
    <item>
      <title>数据流重定向</title>
      <link>http://yl4869.github.io/posts/learn_linux/standard_input_output/</link>
      <pubDate>Sun, 23 Jan 2022 21:38:23 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/standard_input_output/</guid>
      <description>简介 数据流重定向是将某个指令执行后要输出在屏幕上的数据，传输到其他的地方。一是可以简化我们的屏幕输出， 去获取我们有用的数据。同时我们还可以将我们想要的数据存储下来。
你可以通过echo &amp;quot;123&amp;quot;和echo &amp;quot;123&amp;quot; &amp;gt; filename 去简单尝试一下这种方式的特点，第二种可以通过 查看新增的file文件观看内容。
标准输入输出与标准错误输出 基本使用 &amp;gt; 是我们实现这种数据流重导向所用的特殊字符，数据流重导向包括标准输入，标准输出和标准错误输出， 他们的规则如下所示：
名称 代码 符号 标准输入(stdin) 0 &amp;lt;或&amp;laquo; 标准输出(stdout) 1 &amp;gt;或&amp;raquo; 标准错误输出(stderr) 2 2&amp;gt;或2&amp;raquo; &amp;gt; 和 &amp;raquo; 的区别是 &amp;gt; 以覆盖的方法输出内容， &amp;raquo; 则是以累加的方式输出内容。你可以自 己试一试。 标准输入的用法类似，可以尝试一下cat &amp;gt; file 尝试键盘输出，使用[ctrl]+d退出，然后看一下得到的 文件。
/dev/null 垃圾桶 在linux一切皆文件的哲学中 /dev/null是一个特殊的&amp;quot;装置&amp;quot; 你可以将任何你想忽略的内容导向到它，而这些 内容将彻底被丢弃。
特殊写法 如果我们想要将正确与错误数据写入同一个文件时，可能会发生数据交叉写入该文件内的情况，造成次序的错乱， 这个时候你可以使用 2&amp;gt;&amp;amp;1 和 &amp;amp;&amp;gt; 的语法。
find /home -name .bashrc &amp;gt; list 2&amp;gt; list &amp;lt;=错误 find /home -name .bashrc &amp;gt; list 2&amp;amp;&amp;gt;1 &amp;lt;=正确 find /home -name .</description>
    </item>
    
  </channel>
</rss>

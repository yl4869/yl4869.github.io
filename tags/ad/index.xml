<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AD on FunForever</title>
    <link>http://yl4869.github.io/tags/ad/</link>
    <description>Recent content in AD on FunForever</description>
    <generator>Hugo -- 0.140.2</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 11 Apr 2022 19:11:10 +0800</lastBuildDate>
    <atom:link href="http://yl4869.github.io/tags/ad/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dijkstra算法-三种实现与复杂度分析</title>
      <link>http://yl4869.github.io/posts/ad/dijkstra/</link>
      <pubDate>Mon, 11 Apr 2022 19:11:10 +0800</pubDate>
      <guid>http://yl4869.github.io/posts/ad/dijkstra/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。&lt;/p&gt;
&lt;p&gt;算法主要通过维护结点集合S。通过从结点集V-S中选择最短路径最小的结点u,将其加入进S中，并对所有从u发出可到达V-S集合中结点的边进行松弛操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对邻接表进行操作&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;松弛操作：对于一条从 顶点u指向 顶点v的边 u&amp;ndash;&amp;gt;v来说，如果满足  d[u]+w(u,v)&amp;lt;d[v],就更新 d[v],使得 d[v]=d[u]+w(u,v)；这就是对 边uv的一次松弛操作；&lt;/p&gt;
&lt;p&gt;其中，w(u,v)表示边的权重，d(u)表示顶点u到达源s的最短距离(目前已知)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此我们可以将算法理解为三个操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到V-S集合中距离S集合最小结点&lt;/li&gt;
&lt;li&gt;将结点加入S集合中&lt;/li&gt;
&lt;li&gt;对V-S中剩余结点进行松弛操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;算法描述&#34;&gt;算法描述&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://yl4869.github.io/image/AD/1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;解释&#34;&gt;解释&lt;/h2&gt;
&lt;p&gt;算法的主要逻辑为while循环。Q始终为Q=V-S。每一次通过EXTRACT-MIN(Q)取出Q中距离最小值u。并将u放入S集合中。之后在for循环中对Q中剩余结点进行松弛操作。&lt;br&gt;
对距离进行更新。&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;算法通过每次从Q中找出距离最小的一个结点插入到S中，并将Q中剩余的结点距离进行松弛，直到Q中没有结点结束。因为Q中初始结点一共有V个，因此一定会有一次O(V)操作(全部插入)。&lt;/p&gt;
&lt;p&gt;注意到我们每次只需要松弛刚插入结点连接到的表，由于采用邻接表操作，我们对每一个边只会松弛一次，因此一共会执行|E|次。&lt;/p&gt;
&lt;p&gt;找到最小结点的操作可以有多种方式实现，下面介绍三种。&lt;/p&gt;
&lt;h3 id=&#34;利用一次遍历实现常通过维护数组&#34;&gt;利用一次遍历实现(常通过维护数组)&lt;/h3&gt;
&lt;p&gt;我们每一次都通过遍历Q中全部结点找到最小值，这时候需要对一次插入结点都需要执行一个O(V)操作。算法的时间复杂度为&lt;/p&gt;
&lt;p&gt;$$
O(V^2 + E) = O(V^2)
$$&lt;/p&gt;
&lt;h3 id=&#34;利用二叉堆实现&#34;&gt;利用二叉堆实现&lt;/h3&gt;
&lt;p&gt;显然，如果我们每一次都要找到最小值，可以通过使用二叉堆实现优先队列来优化寻找最小值的算法。这样我们可以将查找最小值的操作优化到O(lgV)&lt;/p&gt;
&lt;p&gt;而对于二叉堆，每一次修改距离并加入到二叉堆都需要一次更新，因此复杂了松弛操作，时间复杂度为&lt;/p&gt;
&lt;p&gt;$$
O((V+E)lgV)
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即每一次删除Q中一个结点和将结点距离松弛化都需要lgV时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，是否优于第一种需要考虑E的范围，即图是稀疏图还是稠密图&lt;/p&gt;
&lt;h3 id=&#34;利用斐波那契堆&#34;&gt;利用斐波那契堆&lt;/h3&gt;
&lt;p&gt;斐波那契堆的对于找到最小值并进行删除需要的时间与二叉堆一样，都是O(lgV)，但对松弛操作，斐波那契堆的摊还代价是O(1),因此可以实现更好的优化，他的时间复杂度为&lt;br&gt;
$$
O(VlgV + E)
$$&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on FunForever</title>
    <link>http://yl4869.github.io/posts/</link>
    <description>Recent content in Posts on FunForever</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 19 May 2024 22:27:48 +0800</lastBuildDate><atom:link href="http://yl4869.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>环形缓冲区</title>
      <link>http://yl4869.github.io/posts/circular_buffer/</link>
      <pubDate>Sun, 19 May 2024 22:27:48 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/circular_buffer/</guid>
      <description>环形缓冲区 参考文章：知乎专栏</description>
    </item>
    
    <item>
      <title>Linux小tip-rsync</title>
      <link>http://yl4869.github.io/posts/learn_linux/tips/tip2_rsync/</link>
      <pubDate>Wed, 28 Feb 2024 23:12:49 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/tips/tip2_rsync/</guid>
      <description>简介 rsync 是一个用于文件同步和传输的命令行工具。它可以在本地系统之间或者通过SSH等安全通道在本地和远程系统之间同步文件和目录。
你可能听过 scp，scp 主要通过 SSH 进行加密传输，只能用于本地和远程系统之间的文件拷贝。而 rsync 提供了更多的功能，如增量传输、删除目标端不存在的文件、排除特定文件等。
常见选项 -a, --archive: 归档模式，保留文件的所有元数据，包括权限、所有者、组、时间等。 -v, --verbose: 输出详细信息，显示正在执行的操作。 -r, --recursive: 递归地同步子目录。 -z, --compress: 在传输时压缩数据，可以节省带宽。 -u, --update: 仅传输源目录中更新的文件。 -n, --dry-run: 模拟执行同步操作，显示将要发生的改变但不实际指令同步。 -e, --rsh=COMMAND: 选择在传输时使用的远程 shell 程序，通常是 rsh 或 ssh。 --delete: 删除目标目录中源目录没有的文件。 --exclude=PATTERN: 排除匹配指定模式的文件或目录。 示例 # 本地同步，如果是目录需要 -r 选项 rsync -av /path/to/source /path/to/destination # 本地到远程 rsync -av /path/to/source user@remote_host:/path/to/destination # 远程到本地 rsync -av user@remote_host:/path/to/source/ /path/to/destination/ # 同步并删除目标目录中不存在的文件 rsync -av --delete /path/to/source/ /path/to/destination/ # 排除特定文件或目录的同步 rsync -av --exclude=&amp;#39;*.</description>
    </item>
    
    <item>
      <title>仲裁器</title>
      <link>http://yl4869.github.io/posts/digital_design/arb/</link>
      <pubDate>Fri, 13 Oct 2023 14:06:24 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/digital_design/arb/</guid>
      <description>仲裁器是数字设计中常见的模块，应用广泛。仲裁器往往和其他组件使用在一起以组成仲裁电路。如仲裁器+编码器可以实现优先编码器。
逻辑图 下面是一位仲裁器的逻辑图k
只有当输入为1且当前仍未找到1时输出为真，如果之前已经找到1，输出信号会通知其他阶段已经找到了1。
仲裁器可以实现为迭代电路，我们可以先设计1位逻辑电路，然后逐级连接组成多位的仲裁器:
也可以使用超前进位的方式实现：
verilog 实现 我们可以使用 casex 语句很方便的实现仲裁器：
module Arb_4b(r, g); input [3:0] r; output [3:0] g; reg [3:0] g; always @(*) begin casex(r) 4&amp;#39;b0000: g = 4&amp;#39;b0000; 4&amp;#39;bxxx1: g = 4&amp;#39;b0001; 4&amp;#39;bxx10: g = 4&amp;#39;b0010; 4&amp;#39;bx100: g = 4&amp;#39;b0100; 4&amp;#39;b1000: g = 4&amp;#39;b1000; default: g = 4&amp;#39;hx; endcase end endmodule 当我们想要任意宽度的仲裁器时，可以用下面的实现：
module Arb(r, g); // LSB 优先级最高 parameter n=8; input [n-1:0] r; output [n-1:0] g; wire [n-1:0] c = {(~r[n-2:0] &amp;amp; c[n-2:0]), 1&amp;#39;b1}; assign g = r &amp;amp; c; endmodule module Arb(r, g); // MSB 优先级最高 input [n-1:0] r; output [n-1:0] g; wire [n-1:0] c = {1&amp;#39;b1, (~r[n-1:1] &amp;amp; c[n-1:1])}; assign g = r &amp;amp; c; endmodule 可编程优先级仲裁器 使用位片式标记法可以编写优先级可编程的仲裁器，这里使用独热码负责指示标记，功能的实现为下面的语句：</description>
    </item>
    
    <item>
      <title>RUST: 如何理解字符串，字符串字面量和字符串切片</title>
      <link>http://yl4869.github.io/posts/rust/string_str/</link>
      <pubDate>Sun, 26 Mar 2023 22:37:14 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/rust/string_str/</guid>
      <description>如何理解String，str与&amp;amp;str 字符串，字符串字面量和字符串切片是初学 rust 最困惑的一点，一部分是因为它的各种用法繁杂，经常使用；另一部分也是因为它们所提供的方法繁多，并且有着令人疑惑的相互转换。虽然常读常新，但还是想写一篇博客，分享之外也可以让自己在困惑时快速找到参考而不用翻阅大量网页。
从内存开始 通过了解字符串在内存中的表示，我们可以最直观的了解到他们的不同之处，考虑下面的代码和他们创建的布局。
let s1 = String::from(&amp;#34;Hello&amp;#34;); let s2 = &amp;amp;s1[1..]; let s3 = &amp;#34;Hello&amp;#34;; 他们的内存布局如下
my_name:s1(String) my_name: s2(&amp;amp;str) my_name:s3(&amp;amp;str) [----------------] [–––––––––––] [--------------] +---+---+---+ +–––+–––+ +---+---+ stack frame | • | 6 | 5 | │ • │ 4 │ | • | 4 | +-|-+---+---+ │–+–+–--+ +-|-+---+ | | | | +-------------+ | | | | +-V-+-V-+---+---+---+---+ | heap frame | H | e | l | l | o | | | +---+---+---+---+---+---+ | | | | | preallocated +–-–+–V–+–––+–––+–––+–––+ read-only │ H │ e │ l │ l │ o │ │ memory +–––+–––+–––+–––+–––+–––+ 我们可以发现下面几条事实:</description>
    </item>
    
    <item>
      <title>Part1 Uma to Numa</title>
      <link>http://yl4869.github.io/posts/trans/numa/part1-uma-to-numa/</link>
      <pubDate>Mon, 13 Mar 2023 21:15:02 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/trans/numa/part1-uma-to-numa/</guid>
      <description>NUMA 深度探索：从UMA到NUMA (翻译及总结) 原文连接：numa-deep-dive-part-1-uma-numa
引言 非一致存储访问（NUMA）是一种在现今多处理器系统中使用的共享内存架构。每个CPU被分配了自己的本地内存，同时可以访问系统中其他CPU的内存。访问本地内存提供了低延时-高带宽的性能。而访问其他CPU的拥有的内存则具有较高的延时和较低的带宽。
现代的应用与操作系统（如ESXi）默认支持NUMA，但为了提供最佳性能，应该考虑在使用NUMA时进行虚拟机配置。不正确的设计可能会导致特定虚拟机，乃至运行在ESXi主机所有虚拟机出现性能不一致或整体性能降低的情况。
这个系列旨在介绍CPU架构，内存子系统以及ESXi系统对CPU及内存的调度策略。让你能够创建一个高性能的平台，为高质量服务和更高的整合率奠定基础。在我们讨论现代计算机架构之前，我们想先复习一下共享内存多处理器的历史，这能让我们更好理解今天为什么要使用NUMA系统。
共享内存多处理器架构的演变 我们往往认为一致内存访问的方式更适合低延迟、高带宽的架构，但现在的计算机系统架构限制了它的实现。我们可以通过回顾历史找到并行计算的关键驱动力来找到原因。
在七十年代引入的关系型数据库使得能够提供多用户并发操作与过度数据生成的系统需求变成了主流。尽管单处理器的性能提升已经很耀眼，但多处理器系统能够更好的满足工作负载。为了提供性价比高的系统，共享内存地址空间成为了研究的重点。
注: 毫无疑问通过共享内存地址可以解决很多成本
早期系统使用交叉开关的方式实现共享内存，然而这种设计的复杂性随着处理器核心的增长而增加，使得基于总线的系统在现今更加流行。是提供更多内存可用性的一种非常有性价比的方式。这提供了更多的内存可用性，同时具有很好的性价比。
但是基于总线的系统也带来了可扩展性问题。最大的问题是带宽的限制，这限制了总线容载处理器的数量。将CPU添加到系统中需要考虑两个主要问题：
当一个CPU被添加时，对每个节点带来的带宽下降。 当添加更多处理器时导致总线长度提升，这会带来更高的延迟 CPU性能的增长，尤其是处理器与内存间的速度剪刀差，在过去和现在都严重制约着多处理器。现今处理器与内存间的速度剪刀差增长态势明显，因此如何高效管理内存系统一直是相关研究的重点。其中的一种策略是通过缓存，但这也带来了很多挑战。这些挑战仍是目前CPU设计者要考虑的重点，比如对缓存结构和替换算法的研究，以避免缓存失效。
缓存监测协议 为每个CPU添加上缓存能够很好的提升性能。一方面更加靠近CPU的内存缩短了CPU的访存时间，另一方面直接访问缓存可以降低总线的带宽负载。
共享内存架构中为每个CPU添加cache的主要挑战在于如何允许内存块的多个备份存在。这被称为缓存一致性问题。
缓存监测协议创建了一个不消耗全部总线资源但能提供正确数据的模型。其中最受欢迎的是写无效协议的引入。CPU在写入本地缓存之前会擦除所有缓存的数据备份，使得随后其他CPU对响应数据在缓存中的访问都会失效，再由最近修改数据的CPU本地缓存中提供相应的数据。
这种模型节省了大量的总线带宽，同时也使得一致内存访问系统在九十年代初期得以出现。我们将在第三部分介绍现代缓存一致性的更多细节。
一致存储访问架构 一致存储访问架构（UMA），又被叫做对称多处理器（SMPs），指的是基于总线的多处理器上，每个处理器的访存行为及访问延迟都是一致的。
在UMA系统中，CPU通过系统总线连接到北桥，北桥包含了内存控制器，所有的与内存相关的访问都需要经过北桥。负责管理I/O设备的I/O控制器也连接到北桥上。因此每个I/O信号也需要经过北桥连接到CPU。
通过添加多个总线和内存通道可以增加北桥的带宽以此消除北桥带来的瓶颈问题。在某些系统中还可以将外部内存控制器添加到北桥上来提高内存带宽，同时增加更多内存支持。但缓存监测协议的广播性质导致UMA的可扩展性受到限制。因此UMA架构无法满足未来的负载需求（现在的高速闪存设备每秒已经要处理成百上千的I/O请求）。
注：越多的I/O访问意味着处理器间的缓存监测协议实现越复杂。
非一致内存访问架构 为了提升共享内存多处理器架构的可扩展性和性能，可以考虑三个关键的点：
非一致内存访问 点到点的内连拓扑 可扩展的缓存一致性解决 1.非一致内存访问 NUMA不再使用内存池而是引入了拓扑属性，根据处理器到内存的路径长度进行分类以避免内存访问延迟和带宽瓶颈的问题。实现NUMA需要对处理器系统和芯片架构进行重设计。九十年代末的SGI超级计算机对NUMA架构的引入使得NUMA开始受到关注。NUMA帮助识别内存的位置，在这种系统中需要确定哪个机箱中存储了特定（需要的）内存。
在世纪初，AMD将NUMA引入到UMA系统统治的商业区域。在2003年AMD Opteron 系列出现，其集成的内存控制器下每个CPU都有属于自己的内存库。每个CPU也有属于自己的内存空间。NUMA的操作系统，例如ESXi能够允许工作负载在多个地址空间上（本地和远程），同时也可以优化内存访问。我们用带着两个CPU的系统来介绍本地内存访问和远程内存访问的区别。
连接在CPU1上的内存被看作是本地内存，而连在其他CPU上的内存（这里是CPU2）被认为是远程内存。远程内存由于需要跨越互联接口连接到内存控制器而具有比本地内存更高的延迟。对于系统架构而言，不同的内存有着不同的位置，造成了“非一致”的访存时间。
2.点对点互联 AMD 在AMD Opteron 微架构中引入了点对点互联的 HyperTransport。而因特尔在2007年放弃了他们的双独立总线架构，在他们的Nehalem架构中开始使用QuickPath Architecture。
Nehalem architecture 被认为是因特尔微架构中的一个重大改变，同时也被认为是真正第一代酷睿系列。目前的Broadwell架构是因特尔酷睿系列的第四代（Intel Xeon E5 v5）。最后一张图片中展示了更多关于因特尔微架构世代的信息。在QuickPath 架构中，内存控制器进入到每个CPU核中，同时在系统中引入了点对点的快速互联路径（QPI）作为CPU在系统中的数据连接。
Nehalem 微架构不仅替代了前端总线，还重新组织了服务器处理器的子系统，使之模块化。这种模块化设计被叫做“Uncore”，同时创建了对缓存和互联速度的设计的构建库。移除前端总线也改善了带宽的可扩展性问题，但当内存容量过大时也需要考虑处理器核间的传输带宽问题。
集成内存控制器和QuickPath 互联都是Uncore的一部分，可以通过模型特定寄存器（MSR）进行访问。它们连接到MSR上，提供了处理器核间内部通信的功能。Uncore的模块化还可以为因特尔提供不同的QPI速度，在目前（2016）因特尔的Broadwell-EP 微架构提供了6.4GT/s，8.0GT/s和9.6GT/s的速度。在CPU之间提供了理论最大带宽为25.6GB/s,,32GB/s和38.4GB/s。为了对比，最新前端总线提供了1.6Gt/s和12.8GB/s的平台带宽。
在推出Sandy Bridge处理器时，英特尔将Uncore重新命名为System Agent，但是Uncore这个术语仍然在当前的文档中使用。在第二部分中，您可以了解更多关于QuickPath和Uncore的信息。
可扩展的缓存一致性 处理器核到L3 cache间提供了一条由上百条线组成的私有通道。这种情况下缩小纳米制造工艺的同时增加处理器核数量需要复杂的设计工作，因此这种架构可扩展性很差。为了增强扩展性，Sandy Bridge 架构通过将L3 cache 移除Uncore 部分并引入可扩展的环形芯片互联架构来增强了可扩展性。依靠此，因特尔可以将L3 cache 以切片的方式进行分区和分发来提供更高的带宽和更高的关联性。每个切片提供了2.</description>
    </item>
    
    <item>
      <title>计算机体系结构-CPU性能提升简述</title>
      <link>http://yl4869.github.io/posts/read/1/</link>
      <pubDate>Mon, 19 Dec 2022 21:03:52 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/read/1/</guid>
      <description>前言 随着半导体工艺的升级和芯片技术的发展，为了充分提升CPU的性能出现了各种各样的方式，提升工艺能够极大提升CPU性能，但随着摩尔定律的逐渐失效，优化CPU结构成为了提升CPU性能中越来越重要的一部分。
局部性原理 在CPU频率不断提升的情况下，和CPU进行频繁数据交换的内存速度却提升不够。在这种情况下，CPU直接通过内存进行数据交换时，由于需要等待内存的回应，往往会降低CPU的性能。通过在CPU和内存中间插入Cache作为缓存，能够一定程度上弥补这个问题。
Cache的实现原理 Cache利用空间局部性和时间局部性原理，通过在内存和CPU中间插入一块速度更快的存储器，进而CPU可以先尝试和Cache进行交互，减少CPU访问内存的次数，进而提高系统的整体性能。当Cache中不存在相应数据时，我们会将存储器中的数据和相邻的数据“搬运”到Cache中，这样只需一次访问内存我们可以减少n次内存的访问。
多级Cache 如果都用最先进的工艺实现一个Cache,价格和功耗都是我们无法接受的（当Cache过大时，会由于复杂逻辑产生大的功耗）。因此我们采用多级Cache的方案，不同Cache满足不同需求，如Icache和Dcache代表的L1cache独立于每个Core,L2cache可能在由几个Core进行共用，L3cache可能是整个CPU共用一份。
L1cache分解成Icache和Dcache由于流水线的存在。
无Cache Cache虽好，但并不是所有的处理器都提供了Cache,原因主要有三点：
Cache会增加功耗和成本，占用过大的芯片面积和发热了。 一些处理器本身工作频率不高，没有需要Cache解决的带宽问题。 Cache无法保证实时性，缓存命中和未命中需要不同的CPU处理时间，无法满足实时控制场景的需要。 流水线 CPU工作的执行单调而乏味，正如流水线上的工人一样，因此我们也可以通过流水线的方式提升CPU的处理速度。
流水线的原理 流水线通过将一个任务分成多个部分，利用类似并行的处理方式提高了模块的利用率，提升了吞吐量。
想象一个拧螺丝的工作需要4步，每一步需要2s中，那我们从开始到最后完成任务需要8s，也就是说这个时候我们8s可以生产一个产品，但无论我们执行那一步，其他的三步（材料+设备）都是空闲的，因此我们可以通过流水线的方式进行全速前进，这样在全速前进下我们2s就可以生产一个产品（虽然第一个产品生产完成其实也需要8s等待）。
流水线并不是越深越好 首先流水线的分级需要插入寄存器；流水线间如果出现依赖可能还需要增加逻辑进行判断；同时一旦发生了跳转，我们需要丢弃掉前面所有的预取指令。
更多情况下，我们的流水线需要在性能和功耗间做一个平衡。
乱序执行 不同指令间的执行在流水线中可能存在冒险，这种情况下我们可能需要停顿流水线或添加更多逻辑，而还有一种方式就是通过乱序执行，让数据相关的指令不在一起执行，从而根本上避免了冒险的产生。
SISD和SIMD 我们学习过的大多数指令都是SISD（Single Instruction Single Data），这种数据操作会通过一个指令完成一次数据的运算。而SIMD（Single Instruction Multiple Data）可以完成单指令多数据的操作，一次性读取所有的操作数并进行运算。
为什么要有SIMD 数据密集型计算的大规模出现：图像、视频、音频等数据的处理需求催生了SIMD类型指令的出现。如果说之前处理一帧数据需要无数条SISD的指令，那么可能只需要一条SIMD指令，极大提升了这类处理需求的指令效率。
单发射与多发射 多发射可以在一个时钟周期执行多条指令，这是由于处理器内部多个执行单元的存在（又增加了处理器核的面积和逻辑复杂性）。让我们的处理器可以达到指令级的并行。
静态多发射 静态多发射依赖于编译阶段对可以并行的指令打包，合并成一个长指令，这种实现实现又叫做VLIW（Very long Instruction Wrod），这种实现简单，所需硬件也简单，但由于指令集的兼容问题，这种实现并不能完全被主流处理器支持。
动态多发射 动态多发射在硬件上完成了指令的并行话操作，实现这种方式的处理器又被叫做超标量处理器（SuperScalar）。需要在处理器硬件上实现增加很多逻辑。
EPIC EPIC结合了VILW和SuperScaler的优点，通过在指令中显式提供bit位表达两条指令间有没有相关性，简化了硬件处理两条指令相关的逻辑。
多核 提升芯片面积（如多发射或其他类似的设计增加）在提升CPU性能的同时也带来了更高的功耗，更昂贵的成本。因此对单核的提升出现了一个瓶颈：无法在提升性能的同时降低功耗（相同工艺）。针对于此，多核的时代来临了。
多核处理器能够让多个任务级做到真正并行，而单核处理器只能称之为并发，现代计算机一般都是多个任务同时运行，在这种情况下多核的优势开始显现出来。
片上多核互联 正如在单核流水线和多发射中存在的冲突问题，多核处理器也不能每个核心单独存在，需要进行互联通信。CPU的通信经历了星型连接，总线连接，交叉开关（Crossbar）连接，到达RingBus阶段。RingBus结合总线型和开关型的优点，在成本功耗与通信效率间达到了平衡。但当处理器核心进一步增多时，RingBus的延迟又成为了新的瓶颈。因此面向众核处理器领域又出现了新的片上互联技术：片上网络（Net On Chip, Noc)。
大小核 当工作任务均匀分配到每个核心，并且实现大的负载时，多核处理器的性能得到了充分的发挥。但当工作任务不是很多时，往往会造成处理器中某些核心的空转，白白浪费了电费。为了解决这个问题，不同的厂商都提出了他们的大小核架构方案。可以通过操作系统的调度实现处理器的均匀负载，针对不同的人物，可以使用不同的核心处理问题。
不同厂商的实现不同，比如ARM的big.LITTLE架构中小核心的存在就是为了低功耗，而Intel的E-Core则提供了多线程处理能力，提供的更多是“能效”方面的提升。
超线程（Hyper-Threading） 在主流的X86处理器中，主流CPU都提供了超线程技术，通过增加一定的控制逻辑电路将一个物理处理器当作两个逻辑处理器使用，更大限度提升CPU的资源利用率。
实现原理 通过增加控制逻辑电路，保存各个线程的状态，使不同线程共享一个核心的资源，通过进行上下文切换进行线程转移。
在超线程处理器上这种线程切换可能只需要一个时钟周期，而对于一般处理器的线程切换可能需要上万个时钟周期。
超线程的本质时通过让操作系统分配给CPU更多任务，减少CPU的空闲时间：一个线程空闲时就可以切换到另一个线程了。
超线程一定有利吗 超线程更多适用于高并发的任务中，但对于游戏这种比较吃单核性能的任务下，超线程反而会增加系统开销，影响性能。
现今一些游戏也开始尝试对多线程提供优化，操作系统和各种应用也越来越支持多线程技术。</description>
    </item>
    
    <item>
      <title>新硬盘挂载后发现 df 查询大小和实际大小不一致--Linux的保留空间</title>
      <link>http://yl4869.github.io/posts/learn_linux/reserved_space/</link>
      <pubDate>Thu, 08 Dec 2022 19:29:17 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/reserved_space/</guid>
      <description>前言 在 Linux 上安装一块新硬盘后，发现硬盘大小和挂载后查询到的大小不一致，大概差了 5% 左右，一种可能就是硬盘分区是留下的保留空间造成的。
细节 mkfs.ext4 的man page提供了一部分的解释。
Specify the percentage of the filesystem blocks reserved for the super-user. This avoids fragmentation, and allows root-owned daemons, such as syslogd(8), to continue to function correctly after non-privileged processes are prevented from writing to the filesystem. The default percentage is 5%.
简单来说，ext文件系统为了保证在硬盘百分百利用下还能够写入 root 用户的关键日志等信息，默认预留了5%的磁盘空间。
但我们可以发现，这部分空间很多时候是不需要预留的，尤其是在大的磁盘分区下（例如NAS），可能会导致大量空间的浪费。
解决 针对这个问题，也已经有了解决方案。可以通过tune2fs命令查看保留空间大小和设置保留空间。
tune2fs -l /dev/sde1 | egrep &amp;#34;Block size:|Reserved block count&amp;#34; # Reserved block count: 36628312 # Block size: 4096 # set the reserved space 1% tune2fs -m 1 /dev/sde1 Reference Decrease Reserve Space</description>
    </item>
    
    <item>
      <title>路径规划算法：DFS，BFS，Dijkstra, GBFS 和 A*</title>
      <link>http://yl4869.github.io/posts/ad/pathplan1/</link>
      <pubDate>Fri, 25 Nov 2022 15:46:10 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/ad/pathplan1/</guid>
      <description>介绍 图搜索算法中最常见的一个应用就是路径规划，常见的针对无权图的搜索有DFS和BFS，引入权重后，Dijkstra算法解决了单源最短路径问题，而启发式搜索的存在（GBFS，A*）则能够通过启发函数来提高搜索效率。
DFS 深度优先搜索(Depth First Search)通过维护栈这一数据结构，能够实现对全部路径的搜索，但他会沿着一条路走到最后，在没有结果时才会回头选择另一条路，因此无法保证找到的路径是最优路径。
def dfs(start_point, goal_point): path = [] seen = set() stack = [] seen.add(start_point) stack.append(goal_point) while len(stack) &amp;gt; 0: current = stack.pop() path.append(current) if current == goal_point: break if not graph.neighbors(current): path.pop() continue for next in graph.neighbors(current): if next not in seen: stack.append(next) seen.add(next) return path BFS 广度优先搜索（Breadth First Search）在搜索无权图最短路径时很有用，他会优先探索当前位置的所有方向而不是向着一个方向探索到最后，这也是广度的由来。实现BFS通常依靠队列。同时，我们通过字典来保存我们走过的路径，并通过从终点开始的反向遍历得到路径。
def bfs(start_point, goal_point): frontier = Queue() frontier.put(start_point) came_from = dict() came_from[start_point] = None seen = set() seen.</description>
    </item>
    
    <item>
      <title>Rust: 泛型，特征与特征对象</title>
      <link>http://yl4869.github.io/posts/rust/generics_trait/</link>
      <pubDate>Mon, 14 Nov 2022 10:05:15 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/rust/generics_trait/</guid>
      <description>Rust: 泛型，特征与特征对象 最近在学习 Rust 的一些概念思想，记录一下自己对 Rust 中泛型，特征与特征对象的理解。
泛型 泛型与 CPP 中的模版类似，可以减少代码的重复。泛型会在编译时实现单态化（monomorphization），会将通用代码转换为特定代码，因此不会出现运行时开销。
可以理解为编译器帮你把写的泛型代码重新转换为写了具体类型的代码。
泛型可以用在结构体，枚举，函数乃至方法中，其中枚举和方法可以多讲一下。
泛型在枚举中的实现 泛型在枚举中的实现本身没有要讲的，不过标准库实现的Option&amp;lt;T&amp;gt;和Result&amp;lt;T, E&amp;gt;很想讲一下。
Option 标准库中的泛型定义
pub enum Option&amp;lt;T&amp;gt; { None, Some(T), } 简约而又简单，rust 中并不存在空指针，通过 None 进行替代，Option常使用在返回值中。当返回值可能为一个结果，也有可能失败或缺值时，可以通过模式匹配进行处理。这里的 T 就是泛型说明
Result&amp;lt;T, E&amp;gt; 标准库中的泛型定义
pub enum Result&amp;lt;T, E&amp;gt; { Ok(T), Err(E), } 除了Option可以在结果失败时传递 None，但有时我们想要知道具体的失败信息，Result 实现了这一点。Result&amp;lt;T, E&amp;gt; 拥有两个泛型 T 和 E，在不同的场景下你可以将他们作为不同的类型。
泛型在方法中 泛型在方法中需要在impl后面声明&amp;lt;T&amp;gt;，这里是为了告诉 Rust 类型后面的 T 是一个泛型而不是具体类型，注意这里impl后面提供的泛型声明只与后面具体类型要实现的泛型有关。
与之相应的，你也可以为一个泛型实现他具体类型的方法。
// 对一个泛型实现具体方法，其中方法中又提供了更多的泛型声明 struct Mix&amp;lt;T, U&amp;gt; { x: T, y: U, } impl&amp;lt;T, U&amp;gt; Mix&amp;lt;T, U&amp;gt; { fn mixup&amp;lt;V, W&amp;gt;(self, other: Mix&amp;lt;V, W&amp;gt;) -&amp;gt; Mix&amp;lt;T, W&amp;gt; { //这里提供了另外两个泛型: V和W, 代表other的类型参数 Mix { x: self.</description>
    </item>
    
    <item>
      <title>Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop</title>
      <link>http://yl4869.github.io/posts/verilog/dual-edge_triggered_flip-flop/</link>
      <pubDate>Fri, 11 Nov 2022 19:10:13 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/verilog/dual-edge_triggered_flip-flop/</guid>
      <description>Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop 在做HDLbits时，有一道很有趣的双边沿触发器问题 ，这里记录一下相关内容和解答方式。
问题描述 实现一个双边沿触发器，即在时钟的上升沿和下降沿都被触发。
module top_module ( input clk, input d, output q ); 问题 无法直接通过always @(posedge clk or negedge clk)直接创建双边沿触发器，FPGA 中只能存在单边沿触发器。
但是你可以创建两个触发器，分别是上升沿和下降沿。
解决方案（1） 虽然我们无法直接创建双边沿触发器，但是可以通过使用两个触发器和一个多路选择器实现相同的功能。
module top_module ( input clk, input d, output q ); reg q1; reg q2; always @(posedge clk) begin q1 &amp;lt;= d; end always @(negedge clk) begin q2 &amp;lt;= d; end assign q = clk ? q1 : q2; endmodule 注意，你可能想要两个触发器内都填写q &amp;lt;= d，这在思维上是合理的，但是在实现中会引入多驱问题。</description>
    </item>
    
    <item>
      <title>右值引用: 移动语义</title>
      <link>http://yl4869.github.io/posts/learn_c_cpp/rvalue1/</link>
      <pubDate>Fri, 07 Oct 2022 14:58:49 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_c_cpp/rvalue1/</guid>
      <description>右值引用：移动语义 左值与右值 左值有标识 标识：你有某个值，并有某个值的内存地址，可以安全的使用它
左值(lvalue)可以出现在赋值的左侧（当我们使用他的名称时），也可以出现在赋值的右侧（当我们使用他的值时）。因此当我们称某个值为左值时，他未必出现在等号左侧，而是认为他有标识。
这里的左值严格意义上称为泛左值，包括左值和将亡值两种。
右值可移动，左值不能 有些值并非泛左值，换句话说你无法获得其内存地址并使用。这类值的优点是可以移动他而不是复制它。（通常情况下移动要比赋值开销小很多）。移动一个值意味着他不会在原来的位置，当你称一个值可以移动时，我们认为是右值。
左值是不可移动的，因为这破坏了左值的概念：通过内存地址使用
右值引用的对象，是临时的，即将被销毁。
纯右值 纯右值没有标识，因此我们无法使用他的内存地址，但他是可以移动的（因为是右值）。
值类别汇总 泛左值（glvalue）：有标识 左值：有标识但不能移动 将亡值：有标识，但也可以移动，是之前的某个左值变成了右值引用。 纯右值：没有标识，可以移动。 右值：可移动 左值持久，右值短暂
左值引用与右值引用 重新观察T&amp;amp; 重新观察T&amp;amp;和const T&amp;amp;，他们现在实际上是对左值的引用。左值引用可以绑定到左值，但不可以绑定到右值。
左值引用时，我们将一个对象的内存空间绑定到另一个变量上，因此我们使用的是一个对象在内存中的位置，这是一个左值。
右值引用 通过T&amp;amp;&amp;amp;可以标识一个类型T的右值引用，右值引用引用了一个可移动值，其内容在使用后无需保留。右值引用绑定到右值而非左值（右值引用假定内容无需保留而进行移动的值）。
右值引用意味着：1.右值是临时的，即将被销毁。 2.右值引用的对象不会在其他地方使用。
这两个特性意味着：接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏。
右值引用是左值还是右值 对于左值引用，当我们想要使用他的值时，他是右值，当我们想要使用他的地址（内存空间）时，他是左值。对于右值引用也一样，当我们进行右值引用时，右值的变量已经被右值引用接管了，这个时候的变量可以通过右值引用保存下来，因此可以成为左值。而我们也可以直接使用右值引用的值，这个时候右值引用会作为右值。
移动语义 右值引用支持“移动语义”，利用移动语义，你可以让一个对象转移到另一个对象而非使用拷贝构造，他也可以使用临时对象转移资源。
右值中的数据可以被安全移走使得右值可以用来表达移动语义。
考虑vector对象的实例，当vector容量满时，我们会开辟一块新的空间并将内容拷贝构造到新空间，销毁之前的空间。但拥有了移动语义后，我们可以实现移动而非拷贝，这可以避免成本高昂的内存分配和复制操作。</description>
    </item>
    
    <item>
      <title>数据库系统（一）</title>
      <link>http://yl4869.github.io/posts/database_systems/dbs1/</link>
      <pubDate>Fri, 02 Sep 2022 23:45:14 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/database_systems/dbs1/</guid>
      <description>数据库系统 数据库 什么是数据库？ 将信息以某种形式存储在一起。
数据库的重要位置 系统软件之一，为多种应用软件提供基础。
注意数据库（Database）与数据库管理系统（Database management system，DBMS）的区别。
传统数据整理 传统数据整理的方式：一种方式为 CSV 的表格式存储。
缺点：安全性，效率性，使用时的复杂度等。
如无法保证在数字栏插入的一定是数字。检索需要遍历，出现问题容易直接崩溃等。
早期的DBMS DBMS：软件层面上对数据模型进行定义，提供了增删改查等功能。
早期的数据模型：逻辑与物理紧密结合，必须对特定的数据库场景安排对应的处理应用。
根本原因为物理存储上直接采用应用对数据格式，位置等进行规定，因此切换场景等都需要重新进行设计。
关系模型 基于关系定义了一种数据模型的抽象。
利用一种简单的数据结构（关系）进行数据库存储 用户操作基于高级语言，DBMS 负责具体执行策略 物理存储由 DBMS 负责实现。 关系模型是将无序的各种数据通过关系串联起来，而对这些数据的操作和物理存储的实现都交给了 DBMS，因此使用者可以相对透明的完成对数据的处理。
关系模型也定义了三个概念：
数据结构 数据操作 数据约束 关系模型利用了数学上的关系定义
主键与外键 主键：每个关系中唯一的键，作为该关系的关键字。（如省略，一般会自动生成）
外键：提供关系与关系间的纽带。
DML Data Manipulation Languages，数据操作语言，用来操作数据库表中的记录。
中文可以理解成增删改查四种操作。
常见的两种分类：
Procedural: 指定了做什么，和如何做 Non-Procedural(Declaratice): 仅仅指定了做什么 关系代数 关系代数是对关系模型中各种运算操作的集合（前面说了关系模型其实是一种数学的关系定义）。
注意和数学上的关系运算并不完全相同。
“选择”、“投影”、笛卡尔积（也叫做“叉积”或“交叉连接”）、并集、差集、“重命名”、“自然连接”。
利用关系代数我们可以解释两种 DML 的不同之处：
Procedural：σb id=102(R ▷◁ S)，既解释了做什么，也解释了如何做 Non-Procedural：(retrieve the joined tuples from R and S where bid equals 102，只说明了做什么，没有说明如何做，指定关系代数顺序） 第二种交给了 DBMS 来完成。</description>
    </item>
    
    <item>
      <title>利用分支完成 github pages 博客内容存放和页面部署</title>
      <link>http://yl4869.github.io/posts/make_better_github_pages/</link>
      <pubDate>Fri, 02 Sep 2022 16:21:09 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/make_better_github_pages/</guid>
      <description>前言 我利用github pages作为平台搭建我的博客，我开始选择将博客内容和部署分成两个仓库存放，但这显然造成了复杂性的提升。在阅读 mdbook 的官方文档时，我发现他部署 book 的一个方式是利用一个新的分支进行部署，这样可以将内容和页面放在不同的分支上共同保存，同时有好的规整感。
原理 在 github 仓库的 Settings/Pages 下可以选择利用哪一个分支进行部署。
利用 github worktree 可以将当前分支绑定到一个新建的 worktree 目录上，并通过新的目录进行分支操作。
使用 新建分支 deploy 和 /tmp/blog 目录，利用github worktree 将目录 deploy 分支绑定到目录下。 将生成的页面文件（我这里在public文件夹中），拷贝到 /tmp/blog 目录下 在 /tmp/blog 下利用 git 操作，添加并提交到远程 deploy 分支中。 设置 github pages，用 deploy 分支作为 github pages 部署分支。 现在你可以将内容提交到 main 分支，而将部署提交到 deploy分支。
为什么使用临时目录 使用临时目录的样例来自 mdbook 的文档。因此我只是当一个黑盒来使用。我的想法是为了不破坏其他数据，不过有了解的朋友也欢迎来给我答疑解惑。
我的 Makefile 文件 .PHONY: deploy .PHONY: clean .PHONY: build .PHONY: commit clean: rm -rf public deploy: public @echo &amp;#34;====&amp;gt; deploying to github&amp;#34; -mkdir /tmp/blog git worktree prune -git worktree add /tmp/blog deploy rm -rf /tmp/blog/* cp -rp public/* /tmp/blog/ cd /tmp/blog &amp;amp;&amp;amp; \ git add -A &amp;amp;&amp;amp; \ git commit -m &amp;#34;deployed on $(shell date) by ${USER}&amp;#34; &amp;amp;&amp;amp; \ git push origin deploy cd - build: hugo commit: git add Makefile config.</description>
    </item>
    
    <item>
      <title>数据处理练习</title>
      <link>http://yl4869.github.io/posts/learn_linux/data_wrangling/</link>
      <pubDate>Sat, 14 May 2022 14:58:15 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/data_wrangling/</guid>
      <description>目标 对这个 网页中的数据集进行数据处理,选择一列 找出最大值和最小值, 选择其中两列求出差值并求和.
步骤 对于html, 可以使用wget或curl读入. 处理html内容可以采用pup工具来实现.
下载网页到本地
wget https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm -O pra.html 对网站元素进行查看 最好的方法是使用浏览器的审查元素方式进行查看, 能够较快的找到自己所需的内容.
可以看到我们所需的数据表格在table中,id为table1.更近一步观察可以看到位于tbody中.可以通过pup过滤并 输出内容.
数据处理 通过pup获取html中第一个表格的数据 cat pra.html | pup &amp;#39;table#table1 tbody td next{}&amp;#39; 此时内容如图
去除头部和尾部部分行 对于表格文件,我只关心表格中间的数据，而忽略表头和表尾，这里采用head和tail进行过滤.
删除尾部30行,删除头部208（209-1）行.
head -n -30 tail -n +209 将列变为行，以空格分割 相对于一列，我更喜欢处理以整行数据,这样就可以利用awk的$获取分割.
通过tr命令进行替换
tr &amp;#39;\n&amp;#39; &amp;#39; &amp;#39; awk awk是一种善于处理文本的编程语言,他太强大了,以至于我们可以用awk完成其余的所有操作.
awk &amp;#39;{sum = 0;max = 0; min = 65536;for(i = 2;i &amp;lt; 4302; i+=20) {if(max &amp;lt; $i) max = $i; if(min &amp;gt; $i) \ min = $i; if($i &amp;gt; $(i+1)) sum += $i - $(i+1); if($i &amp;lt;= $(i+1)) sum += $(i+1) - $i;}print max; print \ min; print sum } 正如我们所说，awk是一种编程语言，代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的 分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。</description>
    </item>
    
    <item>
      <title>对大一应该学些什么的一点思考</title>
      <link>http://yl4869.github.io/posts/learn/</link>
      <pubDate>Fri, 15 Apr 2022 23:07:20 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn/</guid>
      <description>前言 最近一直在做一生一芯，跟着做了些PA的项目，感觉自己之前很多所学都有了很多欠缺，也越发发现学校在培养计 划上的自己认为的一些不合理地方，在此记录下:自己如果回到大一，可能会如何开始学习（顺带考虑一下培养计划）。
大一上 应该在大一上学到一门导论课，去知道自己大学四年应该学什么，可以学什么，同时可以将这些知识进行一个简单的串联， 未必要将每一个知识点学的很深，但希望可以覆盖到每一个知识点。
程序设计基础肯定要有，但课设（挺想把C语言课设搬到大一上的，这里一并说了）希望可以有一个培养为上，内容次之的 过程。
现在的课设很多开始已经是报告要卷，内容要卷的状态了。什么数据库，前端，GUI，一些“卷王”做出了很多远超于 课设本身内容的事情。
希望课设是将课上所学实践起来。而不是在各种内容之外的地方去竞争。也希望未来的学弟学妹都能够真正自己思考,动手 写出课设，而不是在网上copy代码。
可以让学生多学一些工具，比如利用git进行团队协作（老实说这个我现在都还没做好），通过make工具链编译。未必要成为 课设加分项，但也可以让学生开始接触一些试试（我现在就在被makefile折磨）。
这里点赞一下我们的实验课老师，他实验课的开始就让我们体会了一些git的用法，据说现在学弟学妹还可以在CG平台实验了。
大一下 学会工具使用！学会工具使用！学会工具使用！
一定需要一门课来教一些工具的使用了，命令行，shell，版本控制，文本编辑&amp;hellip;。狂吹The missing semester of your CS education 。
如果说大一上已经开始接触git了，你可能感受到（或没有）他的便利，如果没有，尝试继续在日常使用。
如果你没有开始，用qq，U盘传文件的方式已经让你感到麻烦，开始git吧，找寻一种更高效（开始可能不）的方法。
学会使用这些工具未必能让你立刻觉得你付出的时间会有回报，但他们一定会穿插在你学习计算机的每一个时刻。
对于C++，老师上课第一件要说的就是：学的是面向对象程序设计，只是用C++来教学，因此将更多实时间放在面向对象 上应该是个好主意。
装一台虚拟机，装上linux（颇有私货），但从无到有掌握linux确实能提高很多你的能力（包括查阅文档）。
建议 老师的PPT很老，对于教学来讲足够了，但对于计算机前沿来讲显得过于陈旧。可以多上网冲浪看一看，现代计算机发展到了哪一个阶段。
多实践，多敲键盘，学会计算机的最好办法。
查阅手册，查看代码，搜索网页。解决问题的最好办法
结语 祝你早日成为计算机科学家</description>
    </item>
    
    <item>
      <title>Dijkstra算法-三种实现与复杂度分析</title>
      <link>http://yl4869.github.io/posts/ad/dijkstra/</link>
      <pubDate>Mon, 11 Apr 2022 19:11:10 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/ad/dijkstra/</guid>
      <description>介绍 Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。
算法主要通过维护结点集合S。通过从结点集V-S中选择最短路径最小的结点u,将其加入进S中，并对所有从u发出可到达V-S集合中结点的边进行松弛操作。
对邻接表进行操作
松弛操作：对于一条从 顶点u指向 顶点v的边 u&amp;ndash;&amp;gt;v来说，如果满足 d[u]+w(u,v)&amp;lt;d[v],就更新 d[v],使得 d[v]=d[u]+w(u,v)；这就是对 边uv的一次松弛操作；
其中，w(u,v)表示边的权重，d(u)表示顶点u到达源s的最短距离(目前已知)
因此我们可以将算法理解为三个操作：
找到V-S集合中距离S集合最小结点 将结点加入S集合中 对V-S中剩余结点进行松弛操作。 算法描述 解释 算法的主要逻辑为while循环。Q始终为Q=V-S。每一次通过EXTRACT-MIN(Q)取出Q中距离最小值u。并将u放入S集合中。之后在for循环中对Q中剩余结点进行松弛操作。
对距离进行更新。
分析 算法通过每次从Q中找出距离最小的一个结点插入到S中，并将Q中剩余的结点距离进行松弛，直到Q中没有结点结束。因为Q中初始结点一共有V个，因此一定会有一次O(V)操作(全部插入)。
注意到我们每次只需要松弛刚插入结点连接到的表，由于采用邻接表操作，我们对每一个边只会松弛一次，因此一共会执行|E|次。
找到最小结点的操作可以有多种方式实现，下面介绍三种。
利用一次遍历实现(常通过维护数组) 我们每一次都通过遍历Q中全部结点找到最小值，这时候需要对一次插入结点都需要执行一个O(V)操作。算法的时间复杂度为
$$ O(V^2 + E) = O(V^2) $$
利用二叉堆实现 显然，如果我们每一次都要找到最小值，可以通过使用二叉堆实现优先队列来优化寻找最小值的算法。这样我们可以将查找最小值的操作优化到O(lgV)
而对于二叉堆，每一次修改距离并加入到二叉堆都需要一次更新，因此复杂了松弛操作，时间复杂度为
$$ O((V+E)lgV) $$
即每一次删除Q中一个结点和将结点距离松弛化都需要lgV时间
因此，是否优于第一种需要考虑E的范围，即图是稀疏图还是稠密图
利用斐波那契堆 斐波那契堆的对于找到最小值并进行删除需要的时间与二叉堆一样，都是O(lgV)，但对松弛操作，斐波那契堆的摊还代价是O(1),因此可以实现更好的优化，他的时间复杂度为
$$ O(VlgV + E) $$</description>
    </item>
    
    <item>
      <title>Rust介绍</title>
      <link>http://yl4869.github.io/posts/rust/rust_1/</link>
      <pubDate>Fri, 18 Mar 2022 15:24:02 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/rust/rust_1/</guid>
      <description>Rust介绍 官网对rust的介绍为一门赋予每个人构建可靠且高效软件能力的语言。
Rust是一门系统编程语言。简单来说，系统编程语言是一种资源受限的编程，你需要对每个字节和每个CPU时钟周期精打细算，做到高效的完成任务。
常见的系统编程应用场景:
操作系统 各种设备驱动 文件系统 数据库 嵌入式设备 内存管理程序 高级编程语言 虚拟化及软件程序 游戏 等等&amp;hellip; 为什么选择Rust 系统编程语言已经有C/CPP了，为什么我还要选择Rust? C语言诞生于1972年，C++诞生于1979年，这至今41+年的时光中一直没有编程语言去挑战他们的地位。
由于时代原因，C和C++是两门过于相信程序员的编程语言，不会去检查程序员出错的代码。
Rust的第一个正式版本发布于2015年，融合了现代编程语言的优秀设计，解决了传统系统编程语言的痛点问题。产生了高性能，可靠性，生产力三个优秀特点。
最值得一提的是可靠性，Rust的设计使得你可以在编译器解决各种错误，而不是运行时。同时他的这种设计也让多核时代的多线程编写变得更加简单。
又有谁没被segmentation fault折磨过呢？
享受编程 一旦你学会了rust，你就会享受到面向编译编译器开发带来的好处（虽然我个人现在还在痛苦当中）。感受前期多用脑子，开发不用脑子的特点了。
官方文档丰富 官方（社区）为Rust提供了许多优良的文档，比如the book，他们本身的优秀使得你可以从官网快速开始学习Rust。
Rust的缺陷之处 学习曲线陡峭 Rust与C-like语言较大的差异使得上手Rust变得困难。为了严格防止未定义行为，Rust又引入了所有权，生命周期等概念。这使得学习Rust的难度进一步提高。
编译时间长 为了保证可靠性，Rust需要在编译时进行大量的检查（编译器教你做事），这使得一个大的项目要花费更多的时间在编译上。更为遗憾的是这个缺点可能需要很久（甚至不可能）改善。
不过现在已经有多线程编译的出现以减少编译时间。
就算你不致力于使用Rust，也可以看一看Rust Rust吸收了许多编程语言的优良设计，并解决了许多过去编程的痛点问题。就算你不使用Rust，去学一学Rust的哲学也可以帮助你成为更好的程序员。</description>
    </item>
    
    <item>
      <title>Linux小tip------tar与gz</title>
      <link>http://yl4869.github.io/posts/learn_linux/tips/tip1/</link>
      <pubDate>Mon, 14 Feb 2022 21:15:57 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/tips/tip1/</guid>
      <description>简介 你可能经常看到.tar与.tar.gz文件，但你可能很少思考过他们的用法。下面将介绍他们的区别
tar tar是打包命令，可以把一大堆的文件和目录打包成一个文件，方便文件的备份和文件在网络中的传输。
弄清打包和压缩的概念，打包并不会减小文件的大小。
当我们想要将多个文件压缩成一个压缩包时，我们需要先对这些文件进行打包，然后再用压缩程序进行压缩。
gz(误) gz并不是一个正确的说法，事实上你可以单独使用gzip等压缩程序对文件进行压缩，常见的.tar.gz是直接用tar打包并通过应用程序进行压缩的一种方式。
永远记得一个事实：linux当中后缀名不是必须的，更多是为了便于区别。
从例子学习使用 tar进行文件打包 1.打包文件
tar -cf file.tar file1 file2 将file1和file2进行打包。-c表示进行打包，-f指定打包文档(file.tar)
2.解包文件
tar -xf file.tar -x表示解包，-f指定解包文档(file.tar)
压缩文件进行文件压缩 这里只介绍利用gzip压缩软件，事实上还有其他的压缩软件可以使用 1.压缩文件
gzip file.tar 2.解压文件
gunzip file.tar.gz 直接利用tar进行打包与解压 1.压缩文件
tar -czvf file.tar.gz file1 file2 -c,-f已经介绍过。-z表示使用的压缩是gzip压缩，-v表示显示所有过程
2.解压文件
tar -xzvf file.tar.gz 现在你应该理解了压缩与解压阶段各种参数的意义。
注意：-f后面必须接文档名，所以作为最后一个参数</description>
    </item>
    
    <item>
      <title>在linux上游玩星际争霸2</title>
      <link>http://yl4869.github.io/posts/learn_linux/starcraftii/</link>
      <pubDate>Sun, 23 Jan 2022 23:42:33 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/starcraftii/</guid>
      <description>简介 限制想要将工作从windows迁移到linux上的一个方面就是游戏。Steam已经通过proton给到了游戏玩家更多的选择。暴雪尚未出现linux版本，但好在还有wine的存在。通过lutris，现在你可以更轻松地在linux上享受游戏。
我会尽量给出官方文档，以便于不同时间的不同用户进行操作时可以减少错误。
操作系统：manjaro
显卡：Nvidia no-free驱动
步骤 1.安装合适的Gpu驱动 https://github.com/lutris/docs/blob/master/InstallingDrivers.md
lutris为我们创建了一个良好的文档说明。你可以选择与你电脑相符的介绍并继续操作。对我的系统manjaro而言，我已经在安装时选择了no-free驱动，因此已经有了一套正确的驱动支持。
安装wine https://github.com/lutris/docs/blob/master/WineDependencies.md
同样，选择你的发行版并按步骤进行操作,这里以我的系统manjaro为例。
修改/etc/pacman.conf,添加[multilib]启动multilib仓库，在文件中添加以下内容：
/etc/pacman.conf -------------------------------------------------------------------------------------- [multilib] Include = /etc/pacman.d/mirrorlist 更新pacman仓库
sudo pacman -Syu 安装wine，要安装的包有点多，但其实很多你已经安装过了，全部的依赖安装可以避免之后出现奇奇怪怪的问题。
sudo pacman -S --needed wine-staging giflib lib32-giflib libpng lib32-libpng libldap lib32-libldap gnutls lib32-gnutls \ mpg123 lib32-mpg123 openal lib32-openal v4l-utils lib32-v4l-utils libpulse lib32-libpulse libgpg-error \ lib32-libgpg-error alsa-plugins lib32-alsa-plugins alsa-lib lib32-alsa-lib libjpeg-turbo lib32-libjpeg-turbo \ sqlite lib32-sqlite libxcomposite lib32-libxcomposite libxinerama lib32-libgcrypt libgcrypt lib32-libxinerama \ ncurses lib32-ncurses opencl-icd-loader lib32-opencl-icd-loader libxslt lib32-libxslt libva lib32-libva gtk3 \ lib32-gtk3 gst-plugins-base-libs lib32-gst-plugins-base-libs vulkan-icd-loader lib32-vulkan-icd-loader 以上，wine安装完成。</description>
    </item>
    
    <item>
      <title>数据流重定向</title>
      <link>http://yl4869.github.io/posts/learn_linux/standard_input_output/</link>
      <pubDate>Sun, 23 Jan 2022 21:38:23 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_linux/standard_input_output/</guid>
      <description>简介 数据流重定向是将某个指令执行后要输出在屏幕上的数据，传输到其他的地方。一是可以简化我们的屏幕输出， 去获取我们有用的数据。同时我们还可以将我们想要的数据存储下来。
你可以通过echo &amp;quot;123&amp;quot;和echo &amp;quot;123&amp;quot; &amp;gt; filename 去简单尝试一下这种方式的特点，第二种可以通过 查看新增的file文件观看内容。
标准输入输出与标准错误输出 基本使用 &amp;gt; 是我们实现这种数据流重导向所用的特殊字符，数据流重导向包括标准输入，标准输出和标准错误输出， 他们的规则如下所示：
名称 代码 符号 标准输入(stdin) 0 &amp;lt;或&amp;laquo; 标准输出(stdout) 1 &amp;gt;或&amp;raquo; 标准错误输出(stderr) 2 2&amp;gt;或2&amp;raquo; &amp;gt; 和 &amp;raquo; 的区别是 &amp;gt; 以覆盖的方法输出内容， &amp;raquo; 则是以累加的方式输出内容。你可以自 己试一试。 标准输入的用法类似，可以尝试一下cat &amp;gt; file 尝试键盘输出，使用[ctrl]+d退出，然后看一下得到的 文件。
/dev/null 垃圾桶 在linux一切皆文件的哲学中 /dev/null是一个特殊的&amp;quot;装置&amp;quot; 你可以将任何你想忽略的内容导向到它，而这些 内容将彻底被丢弃。
特殊写法 如果我们想要将正确与错误数据写入同一个文件时，可能会发生数据交叉写入该文件内的情况，造成次序的错乱， 这个时候你可以使用 2&amp;gt;&amp;amp;1 和 &amp;amp;&amp;gt; 的语法。
find /home -name .bashrc &amp;gt; list 2&amp;gt; list &amp;lt;=错误 find /home -name .bashrc &amp;gt; list 2&amp;amp;&amp;gt;1 &amp;lt;=正确 find /home -name .</description>
    </item>
    
    <item>
      <title>各种资源网站分享</title>
      <link>http://yl4869.github.io/posts/day_day_up/</link>
      <pubDate>Sat, 22 Jan 2022 23:33:15 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/day_day_up/</guid>
      <description>整理了一些平时优质的学习网站，做出分享，长期更新。
各种工具类 一个全栈工程师的工具箱 http://toolbox.phodal.com/
顾名思义，从文档到工具到外设，在无聊的时候可以随意看一看，说不定就找到了提升自己生产力的工具。
CPU仿真器 https://cpulator.01xz.net/
支持Nios II, ARMv7和Mips的处理器仿真。
LaTex https://www.overleaf.com/
LaTex在线编辑工具
godbolt https://godbolt.org/
高级语言到汇编的在线转换工具
FPGA FPGA使用笔记 https://www.kancloud.cn/dlover/fpga
记录了作者学习FPGA时的各种积累，适合新手学习。
使用json绘制波形 https://wavedrom.com/editor.html
可以通过编写json绘制好看的波形图
机器学习 机器学习数据寻找 https://www.zhihu.com/question/342295029/answer/846359794
画出美观的神经网络 http://alexlenail.me/NN-SVG/LeNet.html
前端 前端背景 https://www.pexels.com/zh-cn/
免费高清矢量图片</description>
    </item>
    
    <item>
      <title>上手正则表达式(一)</title>
      <link>http://yl4869.github.io/posts/regularexpressionin/first/</link>
      <pubDate>Mon, 17 Jan 2022 15:18:16 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/regularexpressionin/first/</guid>
      <description>引言 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。
与通配符(如*)类似，正则表达式也是用来进行文本匹配的工具，不过他要更为精确和复杂。学习正则表达式的最好办法就是利用例子学习。
元字符 现在考虑从英文小说里查找hi，你可以使用正则表达式hi,但这样的代价是你会查找到文本中所有有hi的位置,而不是一个单词。为了查找到一个单词你可以使用\bhi\b,他会帮你匹配单词hi存在的位置。
\b是正则表达式中元字符(metacharacter),代表单词的分界处，但请注意\b并不匹配用来分界单词的字符(如空格，标点或者换行符)，他匹配的是一个位置。
更为精确的说法是：\b匹配一个前一个字符和后一个字符不全是\w的位置。
这样的元字符在正则表达式中有很多，他们帮助构建了正则表达式强大的匹配能力。你不需要全部记住，可以在使用中进行查阅，并在实践中掌握他们。
如果你要寻找这样的一个字符串：A单词后面跟着一个B单词，AB中间可以有任意字符存在。可以使用\bA\b.*\bB\b。
这里的.和\*也是两个其他的元字符。.可以匹配除了换行符之外的任何字符，而*比较特殊，他使得前面的内容可以连续重复使用任意次来匹配字符串。
如果你学过离散数学或者计算理论，应该对*不会太过陌生(尤其是学过计算理论)，之后你还会看到+元字符，他们的区别和你在离散数学中他们的区别相同。
下面给出常见的元字符，和使用他们的一些例子 元字符 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 现在我们可以回顾一下\b的精确描述，理解\w的存在。
例子 \ba\w+\b 匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母 a，然后中间至少有一个字母或者数字(\w+)，最后是单词结束处(\b)。用到了\w与+的共同使用,*可以有0，但+至少一个。
\b\w{6}\b 匹配刚好六个字符的单词
^\d{5,12}$ ^ 和 $保证了是整个字符串的匹配，而不是字串，{5，12}代表重复的次数不能少于5次，不能多于12次，否则都不匹配。</description>
    </item>
    
    <item>
      <title>Datalab实验记录</title>
      <link>http://yl4869.github.io/posts/csapp/datalab/</link>
      <pubDate>Fri, 17 Dec 2021 11:14:14 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/csapp/datalab/</guid>
      <description>CSAPP:Data Lab 记录 bitXor(x,y)
使用两种运算实现异或操作（&amp;amp;与～），要求指令数最多为14
//1 /* * bitXor - x^y using only ~ and &amp;amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp;amp; * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { int nx = ~x; int ny = ~y; int fx = x &amp;amp; ny; int fy = nx &amp;amp; y; return ~( (~fx) &amp;amp; (~fy) ); } 采用的是离散数学中亦或的另一种定义方式,$$P \oplus Q = (P \wedge \neg Q) \vee (\neg P \vee Q)$$.</description>
    </item>
    
    <item>
      <title>C语言的声明</title>
      <link>http://yl4869.github.io/posts/learn_c_cpp/declarations/</link>
      <pubDate>Mon, 13 Dec 2021 23:36:06 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_c_cpp/declarations/</guid>
      <description>前言 编程语言的类型模型（type model）一直都是编程语言学习的重点。虽然但是，C语言声明的语法实在是过于奇怪，以至于我们需要花费一些时间认真理解一下，首先思考一下简单的类型模型,考虑下面的C语言声明:
typedef char * string; string punchline = &amp;#34;I&amp;#39;m a frayed knot&amp;#34;; 可以将其分为两部分：变量的类型和变量来理解
被称作 是 变量的类型 string char * 变量 punchline &amp;ldquo;I;m a frayed knot&amp;rdquo; C语言声明的产生 C语言中的声明器（declarator） 简单地说，声明器就是标识符以及和他组合在一起的任何指针、函数符号、数组下标（本表额外添加了初始化内容）
数量 C语言中的名字 C语言中出现的形式 零个或多个 指针 const volatile;volatile;; const; * volatile const 有且只有一个 直接声明器 标识符;标识符[下标];标识符(参数);(声明器) 零个或一个 初始化内容 = 初始值 声明器是一个很模糊的概念，一个简单的思考方式是C语言的声明器是声明中缺少类型以及对类型限定后剩下的部分，这也可以理解 int *p,*q,r 都是什么类型了（p，q是指针，r是int型变量）
C语言的声明 声明增加了至少一个类型说明符（包括类型说明，存储说明和类型限定符），声明器（一个或多个，逗号分割）分号（语句结束）但也请注意，合法的声明存在限定条件，举例说明：
函数的返回值不能是一个函数，所以 foo()() 是非法的 函数的返回值不能是一个数组，所以 foo()[] 是非法的 数组里面不能有函数，所以 foo 是非法的 你也许很快想到，针对这些问题可以用指针解决，所以
函数的返回值允许是一个函数指针，如 int(* fun()) () 函数的返回值允许是一个指向数组的指针， 如 int(*foo())[] 数组里面允许有函数指针 如 int (*foo[])() 数组里面允许有其他数组，所以你经常看到 int foo[][] 优先级规则 C语言声明的优先级规则是阅读C语言声明关键的一步：因为C语言的声明并不是简单的从左到右，下面给出这条规则</description>
    </item>
    
    <item>
      <title>C&#43;&#43;下的四种cast转换方法</title>
      <link>http://yl4869.github.io/posts/learn_c_cpp/type_coversions_cast/</link>
      <pubDate>Wed, 08 Dec 2021 19:36:06 +0800</pubDate>
      
      <guid>http://yl4869.github.io/posts/learn_c_cpp/type_coversions_cast/</guid>
      <description>前言 C++有四种显式类型转换方法，分别是dynamic_cast, reinterpret_cast, static_cast, const_cast。
他们的使用方法为
dynamic_cast &amp;lt;new_type&amp;gt; (expression) reinterpret_cast &amp;lt;new_type&amp;gt; (expression) static_cast &amp;lt;new_type&amp;gt; (expression) const_cast &amp;lt;new_type&amp;gt; (expression) 与之相对，我们也回忆一下传统的类型转换方法
(new_type) expression new_type (expression) 下面就四种类型转换进行简单介绍。
dynamic_cast 有需要提前指出的是，dynamic_cast运算符更多是用来实现RTTI（运行时类型识别 run-time type identification） 功能,其中dynamic_cast用来将基类的指针或引用安全地转移成派生类的指针或引用。
使用RTTI时必须加倍小心，更多时候最好定义虚函数，使用时程序员必须清楚地知道转换的目标模型并且必须检查类型转换是否被成功执行。
dynamic_cast只用在指向类的指针，引用（或void *)上。这种转换允许upcast（从派生类向基类的转换）也能downcast（从基类向派生类的转换），这时需要转过去的指针所指向的目标有效且完整。
举例说明
#include&amp;lt;iostream&amp;gt; #include&amp;lt;exception&amp;gt; using namespace std; class Base {virtual void dummy() {} }; class Derived : public Base { int a; }; int main() { try { Base * pba = new Derived; Base * pbb = new Base; Derived * pd; pd = dynamic_cast&amp;lt;Derived*&amp;gt;(pba); if( pd == 0 ) cout &amp;lt;&amp;lt; &amp;#34;Null pointer on first type-case.</description>
    </item>
    
  </channel>
</rss>

<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | FunForever</title><meta name=keywords content><meta name=description content="Posts - FunForever"><meta name=author content="yunlang"><link rel=canonical href=http://yl4869.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.16d8436cad224c4d1bc5b976fa722facabe72a9afc5a338a823186c9b3ef4685.css integrity="sha256-FthDbK0iTE0bxbl2+nIvrKvnKpr8WjOKgjGGybPvRoU=" rel="preload stylesheet" as=style><link rel=icon href=http://yl4869.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://yl4869.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://yl4869.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://yl4869.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://yl4869.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://yl4869.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Posts"><meta property="og:description" content="欲将心事付瑶琴。知音少，弦断有谁听？"><meta property="og:type" content="website"><meta property="og:url" content="http://yl4869.github.io/posts/"><meta property="og:site_name" content="HomeSite"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="欲将心事付瑶琴。知音少，弦断有谁听？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://yl4869.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://yl4869.github.io/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://yl4869.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=http://yl4869.github.io/categories/ title=种类><span>种类</span></a></li><li><a href=http://yl4869.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=http://yl4869.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=http://yl4869.github.io/links/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://yl4869.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>计算机体系结构-CPU性能提升简述</h2></header><div class=entry-content><p>前言 随着半导体工艺的升级和芯片技术的发展，为了充分提升CPU的性能出现了各种各样的方式，提升工艺能够极大提升CPU性能，但随着摩尔定律的逐渐失效，优化CPU结构成为了提升CPU性能中越来越重要的一部分。
局部性原理 在CPU频率不断提升的情况下，和CPU进行频繁数据交换的内存速度却提升不够。在这种情况下，CPU直接通过内存进行数据交换时，由于需要等待内存的回应，往往会降低CPU的性能。通过在CPU和内存中间插入Cache作为缓存，能够一定程度上弥补这个问题。
Cache的实现原理 Cache利用空间局部性和时间局部性原理，通过在内存和CPU中间插入一块速度更快的存储器，进而CPU可以先尝试和Cache进行交互，减少CPU访问内存的次数，进而提高系统的整体性能。当Cache中不存在相应数据时，我们会将存储器中的数据和相邻的数据“搬运”到Cache中，这样只需一次访问内存我们可以减少n次内存的访问。
多级Cache 如果都用最先进的工艺实现一个Cache,价格和功耗都是我们无法接受的（当Cache过大时，会由于复杂逻辑产生大的功耗）。因此我们采用多级Cache的方案，不同Cache满足不同需求，如Icache和Dcache代表的L1cache独立于每个Core,L2cache可能在由几个Core进行共用，L3cache可能是整个CPU共用一份。
L1cache分解成Icache和Dcache由于流水线的存在。
无Cache Cache虽好，但并不是所有的处理器都提供了Cache,原因主要有三点：
Cache会增加功耗和成本，占用过大的芯片面积和发热了。 一些处理器本身工作频率不高，没有需要Cache解决的带宽问题。 Cache无法保证实时性，缓存命中和未命中需要不同的CPU处理时间，无法满足实时控制场景的需要。 流水线 CPU工作的执行单调而乏味，正如流水线上的工人一样，因此我们也可以通过流水线的方式提升CPU的处理速度。
流水线的原理 流水线通过将一个任务分成多个部分，利用类似并行的处理方式提高了模块的利用率，提升了吞吐量。
想象一个拧螺丝的工作需要4步，每一步需要2s中，那我们从开始到最后完成任务需要8s，也就是说这个时候我们8s可以生产一个产品，但无论我们执行那一步，其他的三步（材料+设备）都是空闲的，因此我们可以通过流水线的方式进行全速前进，这样在全速前进下我们2s就可以生产一个产品（虽然第一个产品生产完成其实也需要8s等待）。
流水线并不是越深越好 首先流水线的分级需要插入寄存器；流水线间如果出现依赖可能还需要增加逻辑进行判断；同时一旦发生了跳转，我们需要丢弃掉前面所有的预取指令。
更多情况下，我们的流水线需要在性能和功耗间做一个平衡。
乱序执行 不同指令间的执行在流水线中可能存在冒险，这种情况下我们可能需要停顿流水线或添加更多逻辑，而还有一种方式就是通过乱序执行，让数据相关的指令不在一起执行，从而根本上避免了冒险的产生。
SISD和SIMD 我们学习过的大多数指令都是SISD（Single Instruction Single Data），这种数据操作会通过一个指令完成一次数据的运算。而SIMD（Single Instruction Multiple Data）可以完成单指令多数据的操作，一次性读取所有的操作数并进行运算。
为什么要有SIMD 数据密集型计算的大规模出现：图像、视频、音频等数据的处理需求催生了SIMD类型指令的出现。如果说之前处理一帧数据需要无数条SISD的指令，那么可能只需要一条SIMD指令，极大提升了这类处理需求的指令效率。
单发射与多发射 多发射可以在一个时钟周期执行多条指令，这是由于处理器内部多个执行单元的存在（又增加了处理器核的面积和逻辑复杂性）。让我们的处理器可以达到指令级的并行。
静态多发射 静态多发射依赖于编译阶段对可以并行的指令打包，合并成一个长指令，这种实现实现又叫做VLIW（Very long Instruction Wrod），这种实现简单，所需硬件也简单，但由于指令集的兼容问题，这种实现并不能完全被主流处理器支持。
动态多发射 动态多发射在硬件上完成了指令的并行话操作，实现这种方式的处理器又被叫做超标量处理器（SuperScalar）。需要在处理器硬件上实现增加很多逻辑。
EPIC EPIC结合了VILW和SuperScaler的优点，通过在指令中显式提供bit位表达两条指令间有没有相关性，简化了硬件处理两条指令相关的逻辑。
多核 提升芯片面积（如多发射或其他类似的设计增加）在提升CPU性能的同时也带来了更高的功耗，更昂贵的成本。因此对单核的提升出现了一个瓶颈：无法在提升性能的同时降低功耗（相同工艺）。针对于此，多核的时代来临了。
多核处理器能够让多个任务级做到真正并行，而单核处理器只能称之为并发，现代计算机一般都是多个任务同时运行，在这种情况下多核的优势开始显现出来。
片上多核互联 正如在单核流水线和多发射中存在的冲突问题，多核处理器也不能每个核心单独存在，需要进行互联通信。CPU的通信经历了星型连接，总线连接，交叉开关（Crossbar）连接，到达RingBus阶段。RingBus结合总线型和开关型的优点，在成本功耗与通信效率间达到了平衡。但当处理器核心进一步增多时，RingBus的延迟又成为了新的瓶颈。因此面向众核处理器领域又出现了新的片上互联技术：片上网络（Net On Chip, Noc)。
大小核 当工作任务均匀分配到每个核心，并且实现大的负载时，多核处理器的性能得到了充分的发挥。但当工作任务不是很多时，往往会造成处理器中某些核心的空转，白白浪费了电费。为了解决这个问题，不同的厂商都提出了他们的大小核架构方案。可以通过操作系统的调度实现处理器的均匀负载，针对不同的人物，可以使用不同的核心处理问题。
不同厂商的实现不同，比如ARM的big.LITTLE架构中小核心的存在就是为了低功耗，而Intel的E-Core则提供了多线程处理能力，提供的更多是“能效”方面的提升。
超线程（Hyper-Threading） 在主流的X86处理器中，主流CPU都提供了超线程技术，通过增加一定的控制逻辑电路将一个物理处理器当作两个逻辑处理器使用，更大限度提升CPU的资源利用率。
实现原理 通过增加控制逻辑电路，保存各个线程的状态，使不同线程共享一个核心的资源，通过进行上下文切换进行线程转移。
在超线程处理器上这种线程切换可能只需要一个时钟周期，而对于一般处理器的线程切换可能需要上万个时钟周期。
超线程的本质时通过让操作系统分配给CPU更多任务，减少CPU的空闲时间：一个线程空闲时就可以切换到另一个线程了。
超线程一定有利吗 超线程更多适用于高并发的任务中，但对于游戏这种比较吃单核性能的任务下，超线程反而会增加系统开销，影响性能。
现今一些游戏也开始尝试对多线程提供优化，操作系统和各种应用也越来越支持多线程技术。</p></div><footer class=entry-footer><span title='2022-12-19 21:03:52 +0800 CST'>December 19, 2022</span>&nbsp;·&nbsp;yunlang</footer><a class=entry-link aria-label="post link to 计算机体系结构-CPU性能提升简述" href=http://yl4869.github.io/posts/read/1/></a></article><article class=post-entry><header class=entry-header><h2>新硬盘挂载后发现 df 查询大小和实际大小不一致--Linux的保留空间</h2></header><div class=entry-content><p>前言 在 Linux 上安装一块新硬盘后，发现硬盘大小和挂载后查询到的大小不一致，大概差了 5% 左右，一种可能就是硬盘分区是留下的保留空间造成的。
细节 mkfs.ext4 的man page提供了一部分的解释。
Specify the percentage of the filesystem blocks reserved for the super-user. This avoids fragmentation, and allows root-owned daemons, such as syslogd(8), to continue to function correctly after non-privileged processes are prevented from writing to the filesystem. The default percentage is 5%.
简单来说，ext文件系统为了保证在硬盘百分百利用下还能够写入 root 用户的关键日志等信息，默认预留了5%的磁盘空间。
但我们可以发现，这部分空间很多时候是不需要预留的，尤其是在大的磁盘分区下（例如NAS），可能会导致大量空间的浪费。
解决 针对这个问题，也已经有了解决方案。可以通过tune2fs命令查看保留空间大小和设置保留空间。
tune2fs -l /dev/sde1 | egrep "Block size:|Reserved block count" # Reserved block count: 36628312 # Block size: 4096 # set the reserved space 1% tune2fs -m 1 /dev/sde1 Reference Decrease Reserve Space...</p></div><footer class=entry-footer><span title='2022-12-08 19:29:17 +0800 CST'>December 8, 2022</span>&nbsp;·&nbsp;yunlang</footer><a class=entry-link aria-label="post link to 新硬盘挂载后发现 df 查询大小和实际大小不一致--Linux的保留空间" href=http://yl4869.github.io/posts/learn_linux/reserved_space/></a></article><article class=post-entry><header class=entry-header><h2>路径规划算法：DFS，BFS，Dijkstra, GBFS 和 A*</h2></header><div class=entry-content><p>介绍 图搜索算法中最常见的一个应用就是路径规划，常见的针对无权图的搜索有DFS和BFS，引入权重后，Dijkstra算法解决了单源最短路径问题，而启发式搜索的存在（GBFS，A*）则能够通过启发函数来提高搜索效率。
DFS 深度优先搜索(Depth First Search)通过维护栈这一数据结构，能够实现对全部路径的搜索，但他会沿着一条路走到最后，在没有结果时才会回头选择另一条路，因此无法保证找到的路径是最优路径。
def dfs(start_point, goal_point): path = [] seen = set() stack = [] seen.add(start_point) stack.append(goal_point) while len(stack) > 0: current = stack.pop() path.append(current) if current == goal_point: break if not graph.neighbors(current): path.pop() continue for next in graph.neighbors(current): if next not in seen: stack.append(next) seen.add(next) return path BFS 广度优先搜索（Breadth First Search）在搜索无权图最短路径时很有用，他会优先探索当前位置的所有方向而不是向着一个方向探索到最后，这也是广度的由来。实现BFS通常依靠队列。同时，我们通过字典来保存我们走过的路径，并通过从终点开始的反向遍历得到路径。
def bfs(start_point, goal_point): frontier = Queue() frontier.put(start_point) came_from = dict() came_from[start_point] = None seen = set() seen....</p></div><footer class=entry-footer><span title='2022-11-25 15:46:10 +0800 CST'>November 25, 2022</span>&nbsp;·&nbsp;yunlang</footer><a class=entry-link aria-label="post link to 路径规划算法：DFS，BFS，Dijkstra, GBFS 和 A*" href=http://yl4869.github.io/posts/ad/pathplan1/></a></article><article class=post-entry><header class=entry-header><h2>Rust: 泛型，特征与特征对象</h2></header><div class=entry-content><p>Rust: 泛型，特征与特征对象 最近在学习 Rust 的一些概念思想，记录一下自己对 Rust 中泛型，特征与特征对象的理解。
泛型 泛型与 CPP 中的模版类似，可以减少代码的重复。泛型会在编译时实现单态化（monomorphization），会将通用代码转换为特定代码，因此不会出现运行时开销。
可以理解为编译器帮你把写的泛型代码重新转换为写了具体类型的代码。
泛型可以用在结构体，枚举，函数乃至方法中，其中枚举和方法可以多讲一下。
泛型在枚举中的实现 泛型在枚举中的实现本身没有要讲的，不过标准库实现的Option&lt;T>和Result&lt;T, E>很想讲一下。
Option 标准库中的泛型定义
pub enum Option&lt;T> { None, Some(T), } 简约而又简单，rust 中并不存在空指针，通过 None 进行替代，Option常使用在返回值中。当返回值可能为一个结果，也有可能失败或缺值时，可以通过模式匹配进行处理。这里的 T 就是泛型说明
Result&lt;T, E> 标准库中的泛型定义
pub enum Result&lt;T, E> { Ok(T), Err(E), } 除了Option可以在结果失败时传递 None，但有时我们想要知道具体的失败信息，Result 实现了这一点。Result&lt;T, E> 拥有两个泛型 T 和 E，在不同的场景下你可以将他们作为不同的类型。
泛型在方法中 泛型在方法中需要在impl后面声明&lt;T>，这里是为了告诉 Rust 类型后面的 T 是一个泛型而不是具体类型，注意这里impl后面提供的泛型声明只与后面具体类型要实现的泛型有关。
与之相应的，你也可以为一个泛型实现他具体类型的方法。
// 对一个泛型实现具体方法，其中方法中又提供了更多的泛型声明 struct Mix&lt;T, U> { x: T, y: U, } impl&lt;T, U> Mix&lt;T, U> { fn mixup&lt;V, W>(self, other: Mix&lt;V, W>) -> Mix&lt;T, W> { //这里提供了另外两个泛型: V和W, 代表other的类型参数 Mix { x: self....</p></div><footer class=entry-footer><span title='2022-11-14 10:05:15 +0800 CST'>November 14, 2022</span>&nbsp;·&nbsp;yunlang</footer><a class=entry-link aria-label="post link to Rust: 泛型，特征与特征对象" href=http://yl4869.github.io/posts/rust/generics_trait/></a></article><article class=post-entry><header class=entry-header><h2>Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop</h2></header><div class=entry-content><p>Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop 在做HDLbits时，有一道很有趣的双边沿触发器问题 ，这里记录一下相关内容和解答方式。
问题描述 实现一个双边沿触发器，即在时钟的上升沿和下降沿都被触发。
module top_module ( input clk, input d, output q ); 问题 无法直接通过always @(posedge clk or negedge clk)直接创建双边沿触发器，FPGA 中只能存在单边沿触发器。
但是你可以创建两个触发器，分别是上升沿和下降沿。
解决方案（1） 虽然我们无法直接创建双边沿触发器，但是可以通过使用两个触发器和一个多路选择器实现相同的功能。
module top_module ( input clk, input d, output q ); reg q1; reg q2; always @(posedge clk) begin q1 &lt;= d; end always @(negedge clk) begin q2 &lt;= d; end assign q = clk ? q1 : q2; endmodule 注意，你可能想要两个触发器内都填写q &lt;= d，这在思维上是合理的，但是在实现中会引入多驱问题。...</p></div><footer class=entry-footer><span title='2022-11-11 19:10:13 +0800 CST'>November 11, 2022</span>&nbsp;·&nbsp;yunlang</footer><a class=entry-link aria-label="post link to Verilog 实现双边沿触发器Dual Edge_triggered_flip Flop" href=http://yl4869.github.io/posts/verilog/dual-edge_triggered_flip-flop/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://yl4869.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=http://yl4869.github.io/>FunForever</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>